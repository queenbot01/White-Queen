// QUEEN ELISA MULTIDEVICE WHATSAPP BOT 2025-2099
 // CREATED BY HASHEN MD
 // FOLLOW MY CHANNEL   White Queenü§ç
 //    ‚è§ÕüÕûÕüÕû ‚ú∞¬© White Queen TOOLS‚è§ÕüÕûÕüÕû ‚ú∞


































































































const { cmd, commands } = require('../command');
const settings = require('../settings');
const prefix = settings.PREFIX;
const fs = require('fs');
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, sleep, fetchJson } = require('../lib/functions2');
const path = require('path');
const converter = require('../data/converter');
const stickerConverter = require('../data/sticker-converter');
const PDFDocument = require('pdfkit');
const { Buffer } = require('buffer');
const { fetchGif, fetchImage, gifToSticker } = require('../lib/sticker-utils');
const os = require("os");
const fetch = require("node-fetch");
const Crypto = require("crypto");
const ffmpegPath = require("@ffmpeg-installer/ffmpeg").path;
const ffmpeg = require("fluent-ffmpeg");
const { videoToWebp } = require('../lib/video-utils');
const { Sticker, createSticker, StickerTypes } = require("wa-sticker-formatter");
const axios = require('axios');
const FormData = require('form-data');
const { translate } = require("@vitalets/google-translate-api")






cmd({
  'on': "body"
}, async (conn, m, store, {
  from,
  body,
  isGroup,
  isAdmins,
  isBotAdmins,
  reply,
  sender
}) => {
  try {
    const badWords = ["wtf", "mia", "xxx", "fuck", 'sex', "huththa", "pakaya", 'ponnaya', "hutto"];

    if (!isGroup || isAdmins || !isBotAdmins) {
      return;
    }

    const messageText = body.toLowerCase();
    const containsBadWord = badWords.some(word => messageText.includes(word));

    if (containsBadWord && settings.ANTI_BAD_WORD === "true") {
      await conn.sendMessage(from, { 'delete': m.key }, { 'quoted': m });
      await conn.sendMessage(from, { 'text': "üö´ ‚ö†Ô∏è BAD WORDS NOT ALLOWED ‚ö†Ô∏è üö´" }, { 'quoted': m });
    }
  } catch (error) {
    console.error(error);
    reply("An error occurred while processing the message.");
  }
});


cmd({
  pattern: "vv2",
  alias: ["wah", "ohh", "oho", "üôÇ", "nice", "ok"],
  desc: "Owner Only - retrieve quoted message back to user",
  category: "owner",
  filename: __filename
}, async (client, message, match, { from, isCreator }) => {
  try {
    if (!isCreator) {
      return; // Simply return without any response if not owner
    }

    if (!match.quoted) {
      return await client.sendMessage(from, {
        text: "*üçÅ Please reply to a view once message!*"
      }, { quoted: message });
    }

    const buffer = await match.quoted.download();
    const mtype = match.quoted.mtype;
    const options = { quoted: message };

    let messageContent = {};
    switch (mtype) {
      case "imageMessage":
        messageContent = {
          image: buffer,
          caption: match.quoted.text || '',
          mimetype: match.quoted.mimetype || "image/jpeg"
        };
        break;
      case "videoMessage":
        messageContent = {
          video: buffer,
          caption: match.quoted.text || '',
          mimetype: match.quoted.mimetype || "video/mp4"
        };
        break;
      case "audioMessage":
        messageContent = {
          audio: buffer,
          mimetype: "audio/mp4",
          ptt: match.quoted.ptt || false
        };
        break;
      default:
        return await client.sendMessage(from, {
          text: "‚ùå Only image, video, and audio messages are supported"
        }, { quoted: message });
    }

    // Forward to user's DM
    await client.sendMessage(message.sender, messageContent, options);
  } catch (error) {
    console.error("vv Error:", error);
    await client.sendMessage(from, {
      text: "‚ùå Error fetching vv message:\n" + error.message
    }, { quoted: message });
  }
});

cmd({
  'on': "body"
}, async (conn, m, store, {
  from,
  body,
  sender,
  isGroup,
  isAdmins,
  isBotAdmins,
  reply
}) => {
  try {
    // Initialize warnings if not exists
    if (!global.warnings) {
      global.warnings = {};
    }

    // Only act in groups where bot is admin and sender isn't admin
    if (!isGroup || isAdmins || !isBotAdmins) {
      return;
    }

    // List of link patterns to detect
    const linkPatterns = [
      /https?:\/\/(?:chat\.whatsapp\.com|wa\.me)\/\S+/gi, // WhatsApp links
      /https?:\/\/(?:api\.whatsapp\.com|wa\.me)\/\S+/gi,  // WhatsApp API links
      /wa\.me\/\S+/gi,                                    // WhatsApp.me links
      /https?:\/\/(?:t\.me|telegram\.me)\/\S+/gi,         // Telegram links
      /https?:\/\/(?:www\.)?\.com\/\S+/gi,                // Generic .com links
      /https?:\/\/(?:www\.)?twitter\.com\/\S+/gi,         // Twitter links
      /https?:\/\/(?:www\.)?linkedin\.com\/\S+/gi,        // LinkedIn links
      /https?:\/\/(?:whatsapp\.com|channel\.me)\/\S+/gi,  // Other WhatsApp/channel links
      /https?:\/\/(?:www\.)?reddit\.com\/\S+/gi,          // Reddit links
      /https?:\/\/(?:www\.)?discord\.com\/\S+/gi,         // Discord links
      /https?:\/\/(?:www\.)?twitch\.tv\/\S+/gi,           // Twitch links
      /https?:\/\/(?:www\.)?vimeo\.com\/\S+/gi,           // Vimeo links
      /https?:\/\/(?:www\.)?dailymotion\.com\/\S+/gi,     // Dailymotion links
      /https?:\/\/(?:www\.)?medium\.com\/\S+/gi           // Medium links
    ];

    // Check if message contains any forbidden links
    const containsLink = linkPatterns.some(pattern => pattern.test(body));

    // Only proceed if anti-link is enabled and link is detected
    if (containsLink && config.ANTI_LINK === 'true') {
      console.log(`Link detected from ${sender}: ${body}`);

      // Try to delete the message
      try {
        await conn.sendMessage(from, {
          delete: m.key
        });
        console.log(`Message deleted: ${m.key.id}`);
      } catch (error) {
        console.error("Failed to delete message:", error);
      }

      // Update warning count for user
      global.warnings[sender] = (global.warnings[sender] || 0) + 1;
      const warningCount = global.warnings[sender];

      // Handle warnings
      if (warningCount < 4) {
        // Send warning message
        await conn.sendMessage(from, {
          text: `‚Äé*‚ôªÔ∏èùêãùêàùêçùêäùêí ùêÄùêëùêÑ ùêçùêéùêì ùêÄùêãùêãùêéùêñùêÑùêÉü™Ä*\n` +
                `*‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚™® ùêñùêÄùêëùêçùêàùêçùêÜ ‚™©‚îÄ‚îÄ‚îÄ‚îÄ*\n` +
                `*‚îú‚ú∫ USER :* @${sender.split('@')[0]}!\n` +
                `*‚îú‚ú∫ COUNT : ${warningCount}*\n` +
                `*‚îú‚ú∫ REASON : LINK SENDING*\n` +
                `*‚îú‚ú∫ WARN LIMIT : 2*\n` +
                `*‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*`,
          mentions: [sender]
        });
      } else {
        // Remove user if they exceed warning limit
        await conn.sendMessage(from, {
          text: `@${sender.split('@')[0]} *HAS BEEN REMOVED - WARN LIMIT EXCEEDED!*`,
          mentions: [sender]
        });
        await conn.groupParticipantsUpdate(from, [sender], "remove");
        delete global.warnings[sender];
      }
    }
  } catch (error) {
    console.error("Anti-link error:", error);
    reply("‚ùå An error occurred while processing the message.");
  }
});


const linkPatterns = [
  /https?:\/\/(?:chat\.whatsapp\.com|wa\.me)\/\S+/gi,
  /^https?:\/\/(www\.)?whatsapp\.com\/channel\/([a-zA-Z0-9_-]+)$/,
  /wa\.me\/\S+/gi,
  /https?:\/\/(?:t\.me|telegram\.me)\/\S+/gi,
  /https?:\/\/(?:www\.)?youtube\.com\/\S+/gi,
  /https?:\/\/youtu\.be\/\S+/gi,
  /https?:\/\/(?:www\.)?facebook\.com\/\S+/gi,
  /https?:\/\/fb\.me\/\S+/gi,
  /https?:\/\/(?:www\.)?instagram\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?twitter\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?tiktok\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?linkedin\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?snapchat\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?pinterest\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?reddit\.com\/\S+/gi,
  /https?:\/\/ngl\/\S+/gi,
  /https?:\/\/(?:www\.)?discord\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?twitch\.tv\/\S+/gi,
  /https?:\/\/(?:www\.)?vimeo\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?dailymotion\.com\/\S+/gi,
  /https?:\/\/(?:www\.)?medium\.com\/\S+/gi
];

cmd({
  on: 'body'
}, async (conn, m, store, {
  from,
  body,
  sender,
  isGroup,
  isAdmins,
  isBotAdmins
}) => {
  try {
    if (!isGroup || isAdmins || !isBotAdmins) {
      return;
    }

    const containsLink = linkPatterns.some(pattern => pattern.test(body));

    if (containsLink && settings.DELETE_LINKS === 'true') {
      await conn.sendMessage(from, { delete: m.key }, { quoted: m });
    }
  } catch (error) {
    console.error(error);
  }
});


cmd({
    pattern: "remove",
    alias: ["kick", "k"],
    desc: "Removes a member from the group",
    category: "admin",
    react: "‚ùå",
    filename: __filename
},
async (conn, mek, m, {
    from, q, isGroup, isBotAdmins, reply, quoted, senderNumber
}) => {
    // Check if the command is used in a group
    if (!isGroup) return reply("‚ùå This command can only be used in groups.");

    // Get the bot owner's number dynamically from conn.user.id
    const botOwner = conn.user.id.split(":")[0];
    if (senderNumber !== botOwner) {
        return reply("‚ùå Only the bot owner can use this command.");
    }

    // Check if the bot is an admin
    if (!isBotAdmins) return reply("‚ùå I need to be an admin to use this command.");

    let number;
    if (m.quoted) {
        number = m.quoted.sender.split("@")[0]; // If replying to a message, get the sender's number
    } else if (q && q.includes("@")) {
        number = q.replace(/[@\s]/g, ''); // If mentioning a user
    } else {
        return reply("‚ùå Please reply to a message or mention a user to remove.");
    }

    const jid = number + "@s.whatsapp.net";

    try {
        await conn.groupParticipantsUpdate(from, [jid], "remove");
        reply(`‚úÖ Successfully removed @${number}`, { mentions: [jid] });
    } catch (error) {
        console.error("Remove command error:", error);
        reply("‚ùå Failed to remove the member.");
    }
});


cmd({
    pattern: "link",
    alias: ["glink", "grouplink"],
    desc: "Get group invite link.",
    category: "group", // Already group
    filename: __filename,
}, async (conn, mek, m, { from, quoted, body, args, q, isGroup, sender, reply }) => {
    try {
        // Ensure this is being used in a group
        if (!isGroup) return reply("ùêìùê°ùê¢ùê¨ ùêÖùêûùêöùê≠ùêÆùê´ùêû ùêàùê¨ ùêéùêßùê•ùê≤ ùêÖùê®ùê´ ùêÜùê´ùê®ùêÆùê©‚ùó");

        // Get the sender's number
        const senderNumber = sender.split('@')[0];
        const botNumber = conn.user.id.split(':')[0];
        
        // Check if the bot is an admin
        const groupMetadata = isGroup ? await conn.groupMetadata(from) : '';
        const groupAdmins = groupMetadata ? groupMetadata.participants.filter(member => member.admin) : [];
        const isBotAdmins = isGroup ? groupAdmins.some(admin => admin.id === botNumber + '@s.whatsapp.net') : false;
        
        if (!isBotAdmins) return reply("ùêèùê•ùêûùêöùê¨ùêû ùêèùê´ùê®ùêØùê¢ùêùùêû ùêåùêû ùêÄùêùùê¶ùê¢ùêß ùêëùê®ùê•ùêû ‚ùó");

        // Check if the sender is an admin
        const isAdmins = isGroup ? groupAdmins.some(admin => admin.id === sender) : false;
        if (!isAdmins) return reply("ùêèùê•ùêûùêöùê¨ùêû ùêèùê´ùê®ùêØùê¢ùêùùêû ùêåùêû ùêÄùêùùê¶ùê¢ùêß ùêëùê®ùê•ùêû ‚ùó");

        // Get the invite code and generate the link
        const inviteCode = await conn.groupInviteCode(from);
        if (!inviteCode) return reply("Failed to retrieve the invite code.");

        const inviteLink = `https://chat.whatsapp.com/${inviteCode}`;

        // Reply with the invite link
        return reply(`*Here is your group invite link:*\n${inviteLink}`);
        
    } catch (error) {
        console.error("Error in invite command:", error);
        reply(`An error occurred: ${error.message || "Unknown error"}`);
    }
});

          


cmd({
    pattern: "join",
    react: "üì¨",
    alias: ["joinme", "f_join"],
    desc: "To Join a Group from Invite link",
    category: "group",
    use: '.join < Group Link >',
    filename: __filename
}, async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isCreator, isDev, isAdmins, reply }) => {
    try {
        const msr = {
            own_cmd: "You don't have permission to use this command."
        };

        // Only allow the creator to use the command
        if (!isCreator) return reply(msr.own_cmd);

        // If there's no input, check if the message is a reply with a link
        if (!q && !quoted) return reply("*Please write the Group Link*Ô∏è üñáÔ∏è");

        let groupLink;

        // If the message is a reply to a group invite link
        if (quoted && quoted.type === 'conversation' && isUrl(quoted.text)) {
            groupLink = quoted.text.split('https://chat.whatsapp.com/')[1];
        } else if (q && isUrl(q)) {
            // If the user provided the link in the command
            groupLink = q.split('https://chat.whatsapp.com/')[1];
        }

        if (!groupLink) return reply("‚ùå *Invalid Group Link* üñáÔ∏è");

        // Accept the group invite
        await conn.groupAcceptInvite(groupLink);
        await conn.sendMessage(from, { text: `‚úîÔ∏è *Successfully Joined*` }, { quoted: mek });

    } catch (e) {
        await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } });
        console.log(e);
        reply(`‚ùå *Error Occurred!!*\n\n${e}`);
    }
});


cmd({
  pattern: "broadcast",
  category: "group",
  desc: "Bot makes a broadcast in all groups",
  filename: __filename,
  use: "<text for broadcast.>"
}, async (conn, mek, m, { q, isGroup, isAdmins, reply }) => {
  try {
    if (!isGroup) return reply("‚ùå This command can only be used in groups!");
    if (!isAdmins) return reply("‚ùå You need to be an admin to broadcast in this group!");

    if (!q) return reply("‚ùå Provide text to broadcast in all groups!");

    let allGroups = await conn.groupFetchAllParticipating();
    let groupIds = Object.keys(allGroups); // Extract group IDs

    reply(`üì¢ Sending Broadcast To ${groupIds.length} Groups...\n‚è≥ Estimated Time: ${groupIds.length * 1.5} seconds`);

    for (let groupId of groupIds) {
      try {
        await sleep(1500); // Avoid rate limits
        await conn.sendMessage(groupId, { text: q }); // Sends only the provided text
      } catch (err) {
        console.log(`‚ùå Failed to send broadcast to ${groupId}:`, err);
      }
    }

    return reply(`‚úÖ Successfully sent broadcast to ${groupIds.length} groups!`);
    
  } catch (err) {
    await m.error(`‚ùå Error: ${err}\n\nCommand: broadcast`, err);
  }
});
cmd({
    pattern: "countryinfo",
    alias: ["cinfo", "country","cinfo2"],
    desc: "Get information about a country",
    category: "convert",
    react: "üåç",
    filename: __filename
},
async (conn, mek, m, { from, args, q, reply, react }) => {
    try {
        if (!q) return reply("Please provide a country name.\nExample: `.countryinfo Pakistan`");

        const apiUrl = `https://api.siputzx.my.id/api/tools/countryInfo?name=${encodeURIComponent(q)}`;
        const { data } = await axios.get(apiUrl);

        if (!data.status || !data.data) {
            await react("‚ùå");
            return reply(`No information found for *${q}*. Please check the country name.`);
        }

        const info = data.data;
        let neighborsText = info.neighbors.length > 0
            ? info.neighbors.map(n => `üåç *${n.name}*`).join(", ")
            : "No neighboring countries found.";

        const text = `üåç *Country Information: ${info.name}* üåç\n\n` +
                     `üèõ *Capital:* ${info.capital}\n` +
                     `üìç *Continent:* ${info.continent.name} ${info.continent.emoji}\n` +
                     `üìû *Phone Code:* ${info.phoneCode}\n` +
                     `üìè *Area:* ${info.area.squareKilometers} km¬≤ (${info.area.squareMiles} mi¬≤)\n` +
                     `üöó *Driving Side:* ${info.drivingSide}\n` +
                     `üí± *Currency:* ${info.currency}\n` +
                     `üî§ *Languages:* ${info.languages.native.join(", ")}\n` +
                     `üåü *Famous For:* ${info.famousFor}\n` +
                     `üåç *ISO Codes:* ${info.isoCode.alpha2.toUpperCase()}, ${info.isoCode.alpha3.toUpperCase()}\n` +
                     `üåé *Internet TLD:* ${info.internetTLD}\n\n` +
                     `üîó *Neighbors:* ${neighborsText}`;

        await conn.sendMessage(from, {
            image: { url: info.flag },
            caption: text,
            contextInfo: { mentionedJid: [m.sender] }
        }, { quoted: mek });

        await react("‚úÖ"); // React after successful response
    } catch (e) {
        console.error("Error in countryinfo command:", e);
        await react("‚ùå");
        reply("An error occurred while fetching country information.");
    }
});
cmd({
    pattern: 'convert',
    alias: ['sticker2img', 'stoimg', 'stickertoimage', 's2i'],
    desc: 'Convert stickers to images',
    category: 'convert',
    react: 'üñºÔ∏è',
    filename: __filename
}, async (client, match, message, { from }) => {
    // Input validation
    if (!message.quoted) {
        return await client.sendMessage(from, {
            text: "‚ú® *Sticker Converter*\n\nPlease reply to a sticker message\n\nExample: `.convert` (reply to sticker)"
        }, { quoted: message });
    }

    if (message.quoted.mtype !== 'stickerMessage') {
        return await client.sendMessage(from, {
            text: "‚ùå Only sticker messages can be converted"
        }, { quoted: message });
    }

    // Send processing message
    await client.sendMessage(from, {
        text: "üîÑ Converting sticker to image..."
    }, { quoted: message });

    try {
        const stickerBuffer = await message.quoted.download();
        const imageBuffer = await stickerConverter.convertStickerToImage(stickerBuffer);

        // Send result
        await client.sendMessage(from, {
            image: imageBuffer,
            caption: "> Powered By ·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢ ü§ç",
            mimetype: 'image/png'
        }, { quoted: message });

    } catch (error) {
        console.error('Conversion error:', error);
        await client.sendMessage(from, {
            text: "‚ùå Please try with a different sticker."
        }, { quoted: message });
    }
});

cmd({
    pattern: 'tomp3',
    desc: 'Convert media to audio',
    category: 'convert',
    react: 'üéµ',
    filename: __filename
}, async (client, match, message, { from }) => {
    // Input validation
    if (!match.quoted) {
        return await client.sendMessage(from, {
            text: "*üîä Please reply to a video/audio message*"
        }, { quoted: message });
    }

    if (!['videoMessage', 'audioMessage'].includes(match.quoted.mtype)) {
        return await client.sendMessage(from, {
            text: "‚ùå Only video/audio messages can be converted"
        }, { quoted: message });
    }

    if (match.quoted.seconds > 300) {
        return await client.sendMessage(from, {
            text: "‚è±Ô∏è Media too long (max 5 minutes)"
        }, { quoted: message });
    }

    // Send processing message and store it
    await client.sendMessage(from, {
        text: "üîÑ Converting to audio..."
    }, { quoted: message });

    try {
        const buffer = await match.quoted.download();
        const ext = match.quoted.mtype === 'videoMessage' ? 'mp4' : 'm4a';
        const audio = await converter.toAudio(buffer, ext);

        // Send result
        await client.sendMessage(from, {
            audio: audio,
            mimetype: 'audio/mpeg'
        }, { quoted: message });

    } catch (e) {
        console.error('Conversion error:', e.message);
        await client.sendMessage(from, {
            text: "‚ùå Failed to process audio"
        }, { quoted: message });
    }
});

cmd({
    pattern: 'toptt',
    desc: 'Convert media to voice message',
    category: 'convert',
    react: 'üéôÔ∏è',
    filename: __filename
}, async (client, match, message, { from }) => {
    // Input validation
    if (!match.quoted) {
        return await client.sendMessage(from, {
            text: "*üó£Ô∏è Please reply to a video/audio message*"
        }, { quoted: message });
    }

    if (!['videoMessage', 'audioMessage'].includes(match.quoted.mtype)) {
        return await client.sendMessage(from, {
            text: "‚ùå Only video/audio messages can be converted"
        }, { quoted: message });
    }

    if (match.quoted.seconds > 60) {
        return await client.sendMessage(from, {
            text: "‚è±Ô∏è Media too long for voice (max 1 minute)"
        }, { quoted: message });
    }

    // Send processing message
    await client.sendMessage(from, {
        text: "üîÑ Converting to voice message..."
    }, { quoted: message });

    try {
        const buffer = await match.quoted.download();
        const ext = match.quoted.mtype === 'videoMessage' ? 'mp4' : 'm4a';
        const ptt = await converter.toPTT(buffer, ext);

        // Send result
        await client.sendMessage(from, {
            audio: ptt,
            mimetype: 'audio/ogg; codecs=opus',
            ptt: true
        }, { quoted: message });

    } catch (e) {
        console.error('PTT conversion error:', e.message);
        await client.sendMessage(from, {
            text: "‚ùå Failed to create voice message"
        }, { quoted: message });
    }
});
cmd({
    pattern: "fetch",
    alias: ["get", "api"],
    desc: "Fetch data from a provided URL or API",
    category: "group",
    react: "üåê",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, args, reply }) => {
    try {
        const q = args.join(' ').trim(); // Extract the URL or API query
        if (!q) return reply('‚ùå Please provide a valid URL or query.');

        if (!/^https?:\/\//.test(q)) return reply('‚ùå URL must start with http:// or https://.');

        const data = await fetchJson(q); // Use your fetchJson utility function to get data
        const content = JSON.stringify(data, null, 2);

        await conn.sendMessage(from, {
            text: `üîç *Fetched Data*:\n\`\`\`${content.slice(0, 2048)}\`\`\``,
            contextInfo: {
                mentionedJid: [m.sender],
                forwardingScore: 999,
                isForwarded: true,
                forwardingSourceMessage: 'Your Data Request',
            }
        }, { quoted: mek });
    } catch (e) {
        console.error("Error in fetch command:", e);
        reply(`‚ùå An error occurred:\n${e.message}`);
    }
});


// Safety Configuration
const SAFETY = {
  MAX_JIDS: 20,
  BASE_DELAY: 2000,  // jawad on top üîù
  EXTRA_DELAY: 4000,  // huh don't copy mine file 
};

cmd({
  pattern: "forward",
  alias: ["fwd"],
  desc: "Bulk forward media to groups",
  category: "owner",
  filename: __filename
}, async (client, message, match, { isOwner }) => {
  try {
    // Owner check
    if (!isOwner) return await message.reply("*üìõ Owner Only Command*");
    
    // Quoted message check
    if (!message.quoted) return await message.reply("*üçÅ Please reply to a message*");

    // ===== [BULLETPROOF JID PROCESSING] ===== //
    let jidInput = "";
    
    // Handle all possible match formats
    if (typeof match === "string") {
      jidInput = match.trim();
    } else if (Array.isArray(match)) {
      jidInput = match.join(" ").trim();
    } else if (match && typeof match === "object") {
      jidInput = match.text || "";
    }
    
    // Extract JIDs (supports comma or space separated)
    const rawJids = jidInput.split(/[\s,]+/).filter(jid => jid.trim().length > 0);
    
    // Process JIDs (accepts with or without @g.us)
    const validJids = rawJids
      .map(jid => {
        // Remove existing @g.us if present
        const cleanJid = jid.replace(/@g\.us$/i, "");
        // Only keep if it's all numbers
        return /^\d+$/.test(cleanJid) ? `${cleanJid}@g.us` : null;
      })
      .filter(jid => jid !== null)
      .slice(0, SAFETY.MAX_JIDS);

    if (validJids.length === 0) {
      return await message.reply(
        "‚ùå No valid group JIDs found\n" +
        "Examples:\n" +
        ".fwd 120363411055156472@g.us,120363333939099948@g.us\n" +
        ".fwd 120363411055156472 120363333939099948"
      );
    }

    // ===== [ENHANCED MEDIA HANDLING - ALL TYPES] ===== //
    let messageContent = {};
    const mtype = message.quoted.mtype;
    
    // For media messages (image, video, audio, sticker, document)
    if (["imageMessage", "videoMessage", "audioMessage", "stickerMessage", "documentMessage"].includes(mtype)) {
      const buffer = await message.quoted.download();
      
      switch (mtype) {
        case "imageMessage":
          messageContent = {
            image: buffer,
            caption: message.quoted.text || '',
            mimetype: message.quoted.mimetype || "image/jpeg"
          };
          break;
        case "videoMessage":
          messageContent = {
            video: buffer,
            caption: message.quoted.text || '',
            mimetype: message.quoted.mimetype || "video/mp4"
          };
          break;
        case "audioMessage":
          messageContent = {
            audio: buffer,
            mimetype: message.quoted.mimetype || "audio/mp4",
            ptt: message.quoted.ptt || false
          };
          break;
        case "stickerMessage":
          messageContent = {
            sticker: buffer,
            mimetype: message.quoted.mimetype || "image/webp"
          };
          break;
        case "documentMessage":
          messageContent = {
            document: buffer,
            mimetype: message.quoted.mimetype || "application/octet-stream",
            fileName: message.quoted.fileName || "document"
          };
          break;
      }
    } 
    // For text messages
    else if (mtype === "extendedTextMessage" || mtype === "conversation") {
      messageContent = {
        text: message.quoted.text
      };
    } 
    // For other message types (forwarding as-is)
    else {
      try {
        // Try to forward the message directly
        messageContent = message.quoted;
      } catch (e) {
        return await message.reply("‚ùå Unsupported message type");
      }
    }

    // ===== [OPTIMIZED SENDING WITH PROGRESS] ===== //
    let successCount = 0;
    const failedJids = [];
    
    for (const [index, jid] of validJids.entries()) {
      try {
        await client.sendMessage(jid, messageContent);
        successCount++;
        
        // Progress update (every 10 groups instead of 5)
        if ((index + 1) % 10 === 0) {
          await message.reply(`üîÑ Sent to ${index + 1}/${validJids.length} groups...`);
        }
        
        // Apply reduced delay
        const delayTime = (index + 1) % 10 === 0 ? SAFETY.EXTRA_DELAY : SAFETY.BASE_DELAY;
        await new Promise(resolve => setTimeout(resolve, delayTime));
        
      } catch (error) {
        failedJids.push(jid.replace('@g.us', ''));
        await new Promise(resolve => setTimeout(resolve, SAFETY.BASE_DELAY));
      }
    }

    // ===== [COMPREHENSIVE REPORT] ===== //
    let report = `‚úÖ *Forward Complete*\n\n` +
                 `üì§ Success: ${successCount}/${validJids.length}\n` +
                 `üì¶ Content Type: ${mtype.replace('Message', '') || 'text'}\n`;
    
    if (failedJids.length > 0) {
      report += `\n‚ùå Failed (${failedJids.length}): ${failedJids.slice(0, 5).join(', ')}`;
      if (failedJids.length > 5) report += ` +${failedJids.length - 5} more`;
    }
    
    if (rawJids.length > SAFETY.MAX_JIDS) {
      report += `\n‚ö†Ô∏è Note: Limited to first ${SAFETY.MAX_JIDS} JIDs`;
    }

    await message.reply(report);

  } catch (error) {
    console.error("Forward Error:", error);
    await message.reply(
      `üí¢ Error: ${error.message.substring(0, 100)}\n\n` +
      `Please try again or check:\n` +
      `1. JID formatting\n` +
      `2. Media type support\n` +
      `3. Bot permissions`
    );
  }
});

cmd({
    pattern: "rcolor",
    desc: "Generate a random color with name and code.",
    category: "download",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        const colorNames = [
            "Red", "Green", "Blue", "Yellow", "Orange", "Purple", "Pink", "Brown", "Black", "White", 
            "Gray", "Cyan", "Magenta", "Violet", "Indigo", "Teal", "Lavender", "Turquoise"
        ];
        
        const randomColorHex = "#" + Math.floor(Math.random()*16777215).toString(16);
        const randomColorName = colorNames[Math.floor(Math.random() * colorNames.length)];

        reply(`üé® *Random Color:* \nName: ${randomColorName}\nCode: ${randomColorHex}`);
    } catch (e) {
        console.error("Error in .randomcolor command:", e);
        reply("‚ùå An error occurred while generating the random color.");
    }
});

cmd({
    pattern: "binary",
    desc: "Convert text into binary format.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        if (!args.length) return reply("‚ùå Please provide the text to convert to binary.");

        const textToConvert = args.join(" ");
        const binaryText = textToConvert.split('').map(char => {
            return `00000000${char.charCodeAt(0).toString(2)}`.slice(-8);
        }).join(' ');

        reply(`üîë *Binary Representation:* \n${binaryText}`);
    } catch (e) {
        console.error("Error in .binary command:", e);
        reply("‚ùå An error occurred while converting to binary.");
    }
});

cmd({
    pattern: "dbinary",
    desc: "Decode binary string into text.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        if (!args.length) return reply("‚ùå Please provide the binary string to decode.");

        const binaryString = args.join(" ");
        const textDecoded = binaryString.split(' ').map(bin => {
            return String.fromCharCode(parseInt(bin, 2));
        }).join('');

        reply(`üîì *Decoded Text:* \n${textDecoded}`);
    } catch (e) {
        console.error("Error in .binarydecode command:", e);
        reply("‚ùå An error occurred while decoding the binary string.");
    }
});


cmd({
    pattern: "base64",
    desc: "Encode text into Base64 format.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure the user provided some text
        if (!args.length) return reply("‚ùå Please provide the text to encode into Base64.");

        const textToEncode = args.join(" ");
        
        // Encode the text into Base64
        const encodedText = Buffer.from(textToEncode).toString('base64');
        
        // Send the encoded Base64 text
        reply(`üîë *Encoded Base64 Text:* \n${encodedText}`);
    } catch (e) {
        console.error("Error in .base64 command:", e);
        reply("‚ùå An error occurred while encoding the text into Base64.");
    }
});

cmd({
    pattern: "unbase64",
    desc: "Decode Base64 encoded text.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure the user provided Base64 text
        if (!args.length) return reply("‚ùå Please provide the Base64 encoded text to decode.");

        const base64Text = args.join(" ");
        
        // Decode the Base64 text
        const decodedText = Buffer.from(base64Text, 'base64').toString('utf-8');
        
        // Send the decoded text
        reply(`üîì *Decoded Text:* \n${decodedText}`);
    } catch (e) {
        console.error("Error in .unbase64 command:", e);
        reply("‚ùå An error occurred while decoding the Base64 text.");
    }
});

cmd({
    pattern: "urlencode",
    desc: "Encode text into URL encoding.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        if (!args.length) return reply("‚ùå Please provide the text to encode into URL encoding.");

        const textToEncode = args.join(" ");
        const encodedText = encodeURIComponent(textToEncode);

        reply(`üîë *Encoded URL Text:* \n${encodedText}`);
    } catch (e) {
        console.error("Error in .urlencode command:", e);
        reply("‚ùå An error occurred while encoding the text.");
    }
});

cmd({
    pattern: "urldecode",
    desc: "Decode URL encoded text.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        if (!args.length) return reply("‚ùå Please provide the URL encoded text to decode.");

        const encodedText = args.join(" ");
        const decodedText = decodeURIComponent(encodedText);

        reply(`üîì *Decoded Text:* \n${decodedText}`);
    } catch (e) {
        console.error("Error in .urldecode command:", e);
        reply("‚ùå An error occurred while decoding the URL encoded text.");
    }
});

cmd({
    pattern: "roll",
    desc: "Roll a dice (1-6).",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        // Roll a dice (generate a random number between 1 and 6)
        const result = Math.floor(Math.random() * 6) + 1;
        
        // Send the result
        reply(`üé≤ You rolled: *${result}*`);
    } catch (e) {
        console.error("Error in .roll command:", e);
        reply("‚ùå An error occurred while rolling the dice.");
    }
}); 


cmd({
    pattern: "coinflip",
    desc: "Flip a coin and get Heads or Tails.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        // Simulate coin flip (randomly choose Heads or Tails)
        const result = Math.random() < 0.5 ? "Heads" : "Tails";
        
        // Send the result
        reply(`ü™ô Coin Flip Result: *${result}*`);
    } catch (e) {
        console.error("Error in .coinflip command:", e);
        reply("‚ùå An error occurred while flipping the coin.");
    }
});

cmd({
    pattern: "flip",
    desc: "Flip the text you provide.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure text is provided
        if (!args.length) return reply("‚ùå Please provide the text to flip.");

        // Flip the text
        const flippedText = args.join(" ").split('').reverse().join('');
        
        // Send the flipped text
        reply(`üîÑ Flipped Text: *${flippedText}*`);
    } catch (e) {
        console.error("Error in .flip command:", e);
        reply("‚ùå An error occurred while flipping the text.");
    }
});

cmd({
    pattern: "pick",
    desc: "Pick between two choices.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure two options are provided
        if (args.length < 2) return reply("‚ùå Please provide two choices to pick from. Example: `.pick Ice Cream, Pizza`");

        // Pick a random option
        const option = args.join(" ").split(',')[Math.floor(Math.random() * 2)].trim();
        
        // Send the result
        reply(`üéâ Bot picks: *${option}*`);
    } catch (e) {
        console.error("Error in .pick command:", e);
        reply("‚ùå An error occurred while processing your request.");
    }
});

cmd({
    pattern: "timenow",
    desc: "Check the current local time.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        // Get current date and time
        const now = new Date();
        
        // Get local time in Pakistan timezone (Asia/Karachi)
        const localTime = now.toLocaleTimeString("en-US", { 
            hour: "2-digit", 
            minute: "2-digit", 
            second: "2-digit", 
            hour12: true,
            timeZone: "Asia/Karachi" // Setting Pakistan's time zone explicitly
        });
        
        // Send the local time as reply
        reply(`üïí Current Local Time in Pakistan: ${localTime}`);
    } catch (e) {
        console.error("Error in .timenow command:", e);
        reply("‚ùå An error occurred. Please try again later.");
    }
});

cmd({
    pattern: "date",
    desc: "Check the current date.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { reply }) => {
    try {
        // Get current date
        const now = new Date();
        
        // Get the formatted date (e.g., "Monday, January 15, 2025")
        const currentDate = now.toLocaleDateString("en-US", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric"
        });
        
        // Send the current date as reply
        reply(`üìÖ Current Date: ${currentDate}`);
    } catch (e) {
        console.error("Error in .date command:", e);
        reply("‚ùå An error occurred. Please try again later.");
    }
});

cmd({
    pattern: "shapar",
    desc: "Send shapar ASCII art with mentions.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, reply }) => {
    try {
        // Ensure the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Extract the mentioned user
        const mentionedUser = m.message.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
        if (!mentionedUser) {
            return reply("Please mention a user to send the ASCII art to.");
        }

        // Shapar ASCII Art
        const asciiArt = `
          _______
       .-'       '-.
      /           /|
     /           / |
    /___________/  |
    |   _______ |  |
    |  |  \\ \\  ||  |
    |  |   \\ \\ ||  |
    |  |____\\ \\||  |
    |  '._  _.'||  |
    |    .' '.  ||  |
    |   '.___.' ||  |
    |___________||  |
    '------------'  |
     \\_____________\\|
`;

        // Message to send
        const message = `üòÇ @${mentionedUser.split("@")[0]}!\nüòÇ that for you:\n\n${asciiArt}`;

        // Send the message with mentions
        await conn.sendMessage(from, {
            text: message,
            mentions: [mentionedUser],
        }, { quoted: m });

    } catch (e) {
        console.error("Error in .shapar command:", e);
        reply("An error occurred while processing the command. Please try again.");
    }
});

cmd({
    pattern: "rate",
    desc: "Rate someone out of 10.",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, reply }) => {
    try {
        if (!isGroup) return reply("This command can only be used in groups.");

        const mentionedUser = m.message.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
        if (!mentionedUser) return reply("Please mention someone to rate.");

        const randomRating = Math.floor(Math.random() * 10) + 1;
        const message = `@${mentionedUser.split("@")[0]} is rated ${randomRating}/10.`;

        await conn.sendMessage(from, { text: message, mentions: [mentionedUser] }, { quoted: m });
    } catch (e) {
        console.error("Error in .rate command:", e);
        reply("An error occurred. Please try again.");
    }
});

cmd({
    pattern: "countx",
    desc: "Start a reverse countdown from the specified number to 1.",
    category: "owner",
    filename: __filename
},
async (conn, mek, m, { args, reply, senderNumber }) => {
    try {
        // Get the bot owner's number dynamically from conn.user.id
        const botOwner = conn.user.id.split(":")[0]; // Extract the bot owner's number
        if (senderNumber !== botOwner) {
            return reply("‚ùé Only the bot owner can use this command.");
        }

        // Ensure arguments are provided
        if (!args[0]) {
            return reply("‚ú≥Ô∏è Use this command like:\n *Example:* .countx 10");
        }

        const count = parseInt(args[0].trim());

        // Validate the input
        if (isNaN(count) || count <= 0 || count > 50) {
            return reply("‚ùé Please specify a valid number between 1 and 50.");
        }

        reply(`‚è≥ Starting reverse countdown from ${count}...`);

        for (let i = count; i >= 1; i--) {
            await conn.sendMessage(m.chat, { text: `${i}` }, { quoted: mek });
            await sleep(1000); // 1-second delay between messages
        }

        reply(`‚úÖ Countdown completed.`);
    } catch (e) {
        console.error(e);
        reply("‚ùé An error occurred while processing your request.");
    }
});

cmd({
    pattern: "count",
    desc: "Start a countdown from 1 to the specified number.",
    category: "owner",
    filename: __filename
},
async (conn, mek, m, { args, reply, senderNumber }) => {
    try {
        // Get the bot owner's number dynamically from conn.user.id
        const botOwner = conn.user.id.split(":")[0]; // Extract the bot owner's number
        if (senderNumber !== botOwner) {
            return reply("‚ùé Only the bot owner can use this command.");
        }

        // Ensure arguments are provided
        if (!args[0]) {
            return reply("‚ú≥Ô∏è Use this command like:\n *Example:* .count 10");
        }

        const count = parseInt(args[0].trim());

        // Validate the input
        if (isNaN(count) || count <= 0 || count > 50) {
            return reply("‚ùé Please specify a valid number between 1 and 50.");
        }

        reply(`‚è≥ Starting countdown to ${count}...`);

        for (let i = 1; i <= count; i++) {
            await conn.sendMessage(m.chat, { text: `${i}` }, { quoted: mek });
            await sleep(1000); // 1-second delay between messages
        }

        reply(`‚úÖ Countdown completed.`);
    } catch (e) {
        console.error(e);
        reply("‚ùé An error occurred while processing your request.");
    }
});


cmd({
    pattern: "calculate",
    alias: ["calc"],
    desc: "Evaluate a mathematical expression.",
    category: "group",
    filename: __filename
},
async (conn, mek, m, { args, reply }) => {
    try {
        // Ensure arguments are provided
        if (!args[0]) {
            return reply("‚ú≥Ô∏è Use this command like:\n *Example:* .calculate 5+3*2");
        }

        const expression = args.join(" ").trim();

        // Validate the input to prevent unsafe operations
        if (!/^[0-9+\-*/().\s]+$/.test(expression)) {
            return reply("‚ùé Invalid expression. Only numbers and +, -, *, /, ( ) are allowed.");
        }

        // Evaluate the mathematical expression
        let result;
        try {
            result = eval(expression);
        } catch (e) {
            return reply("‚ùé Error in calculation. Please check your expression.");
        }

        // Reply with the result
        reply(`‚úÖ Result of "${expression}" is: ${result}`);
    } catch (e) {
        console.error(e);
        reply("‚ùé An error occurred while processing your request.");
    }
});

cmd({
    pattern: "tempnum",
    alias: ["fakenum", "tempnumber"],
    desc: "Get temporary numbers & OTP instructions",
    category: "group",
    react: "üì±",
    use: "<country-code>"
},
async (conn, mek, m, { from, args, reply }) => {
    try {
        // Mandatory country code check
        if (!args || args.length < 1) {
            return reply(`‚ùå *Usage:* .tempnum <country-code>\nExample: .tempnum us\n\nüì¶ Use .otpbox <number>* to check OTPs`);
        }

        const countryCode = args[0].toLowerCase();
        
        // API call with validation
        const { data } = await axios.get(
            `https://api.vreden.my.id/api/tools/fakenumber/listnumber?id=${countryCode}`,
            { 
                timeout: 10000,
                validateStatus: status => status === 200
            }
        );

        // Fixed syntax error here - added missing parenthesis
        if (!data?.result || !Array.isArray(data.result)) {
            console.error("Invalid API structure:", data);
            return reply(`‚ö† Invalid API response format\nTry .tempnum us`);
        }

        if (data.result.length === 0) {
            return reply(`üì≠ No numbers available for *${countryCode.toUpperCase()}*\nTry another country code!\n\nUse .otpbox <number> after selection`);
        }

        // Process numbers
        const numbers = data.result.slice(0, 25);
        const numberList = numbers.map((num, i) => 
            `${String(i+1).padStart(2, ' ')}. ${num.number}`
        ).join("\n");

        // Final message with OTP instructions
        await reply(
            `‚ï≠‚îÄ‚îÄ„Äå üì± TEMPORARY NUMBERS „Äç\n` +
            `‚îÇ\n` +
            `‚îÇ Country: ${countryCode.toUpperCase()}\n` +
            `‚îÇ Numbers Found: ${numbers.length}\n` +
            `‚îÇ\n` +
            `${numberList}\n\n` +
            `‚ï∞‚îÄ‚îÄ„Äå üì¶ USE: .otpbox <number> „Äç\n` +
            `_Example: .otpbox +1234567890_`
        );

    } catch (err) {
        console.error("API Error:", err);
        const errorMessage = err.code === "ECONNABORTED" ? 
            `‚è≥ *Timeout*: API took too long\nTry smaller country codes like 'us', 'gb'` :
            `‚ö† *Error*: ${err.message}\nUse format: .tempnum <country-code>`;
            
        reply(`${errorMessage}\n\nüîë Remember: ${prefix}otpinbox <number>`);
    }
});

cmd({
    pattern: "templist",
    alias: ["tempnumberlist", "tempnlist", "listnumbers"],
    desc: "Show list of countries with temp numbers",
    category: "group",
    react: "üåç",
    filename: __filename,
    use: ".templist"
},
async (conn, m, { reply }) => {
    try {
        const { data } = await axios.get("https://api.vreden.my.id/api/tools/fakenumber/country");

        if (!data || !data.result) return reply("‚ùå Couldn't fetch country list.");

        const countries = data.result.map((c, i) => `*${i + 1}.* ${c.title} \`(${c.id})\``).join("\n");

        await reply(`üåç *Total Available Countries:* ${data.result.length}\n\n${countries}`);
    } catch (e) {
        console.error("TEMP LIST ERROR:", e);
        reply("‚ùå Failed to fetch temporary number country list.");
    }
});

cmd({
    pattern: "otpbox",
    alias: ["checkotp", "getotp"],
    desc: "Check OTP messages for temporary number",
    category: "group",
    react: "üîë",
    use: "<full-number>"
},
async (conn, mek, m, { from, args, reply }) => {
    try {
        // Validate input
        if (!args[0] || !args[0].startsWith("+")) {
            return reply(`‚ùå *Usage:* .otpbox <full-number>\nExample: .otpbox +9231034481xx`);
        }

        const phoneNumber = args[0].trim();
        
        // Fetch OTP messages
        const { data } = await axios.get(
            `https://api.vreden.my.id/api/tools/fakenumber/message?nomor=${encodeURIComponent(phoneNumber)}`,
            { 
                timeout: 10000,
                validateStatus: status => status === 200
            }
        );

        // Validate response
        if (!data?.result || !Array.isArray(data.result)) {
            return reply("‚ö† No OTP messages found for this number");
        }

        // Format OTP messages
        const otpMessages = data.result.map(msg => {
            // Extract OTP code (matches common OTP patterns)
            const otpMatch = msg.content.match(/\b\d{4,8}\b/g);
            const otpCode = otpMatch ? otpMatch[0] : "Not found";
            
            return `‚îå *From:* ${msg.from || "Unknown"}
‚îÇ *Code:* ${otpCode}
‚îÇ *Time:* ${msg.time_wib || msg.timestamp}
‚îî *Message:* ${msg.content.substring(0, 50)}${msg.content.length > 50 ? "..." : ""}`;
        }).join("\n\n");

        await reply(
            `‚ï≠‚îÄ‚îÄ„Äå üîë OTP MESSAGES „Äç\n` +
            `‚îÇ Number: ${phoneNumber}\n` +
            `‚îÇ Messages Found: ${data.result.length}\n` +
            `‚îÇ\n` +
            `${otpMessages}\n` +
            `‚ï∞‚îÄ‚îÄ„Äå üìå Use .tempnum to get numbers „Äç`
        );

    } catch (err) {
        console.error("OTP Check Error:", err);
        const errorMsg = err.code === "ECONNABORTED" ?
            "‚åõ OTP check timed out. Try again later" :
            `‚ö† Error: ${err.response?.data?.error || err.message}`;
        
        reply(`${errorMsg}\n\nUsage: .otpbox +9231034481xx`);
    }
});
cmd({
    pattern: "topdf",
    alias: ["pdf","topdf"],use: '.topdf',
    desc: "Convert provided text to a PDF file.",
    react: "üìÑ",
    category: "convert",
    filename: __filename
},
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!q) return reply("Please provide the text you want to convert to PDF. *Eg* `.topdf` *Pakistan ZindaBad üáµüá∞*");

        // Create a new PDF document
        const doc = new PDFDocument();
        let buffers = [];
        doc.on('data', buffers.push.bind(buffers));
        doc.on('end', async () => {
            const pdfData = Buffer.concat(buffers);

            // Send the PDF file
            await conn.sendMessage(from, {
                document: pdfData,
                mimetype: 'application/pdf',
                fileName: '·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢.pdf',
                caption: `
*üìÑ PDF created successully!*

> ¬© Created By ·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢ üíú`
            }, { quoted: mek });
        });

        // Add text to the PDF
        doc.text(q);

        // Finalize the PDF and end the stream
        doc.end();

    } catch (e) {
        console.error(e);
        reply(`Error: ${e.message}`);
    } 
});
cmd({
    pattern: "person",
    react: "üë§",
    alias: ["userinfo", "profile"],
    desc: "Get complete user profile information",
    category: "group",
    use: '.person [@tag or reply]',
    filename: __filename
},
async (conn, mek, m, { from, sender, isGroup, reply, quoted, participants }) => {
    try {
        // 1. DETERMINE TARGET USER
        let userJid = quoted?.sender || 
                     mek.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0] || 
                     sender;

        // 2. VERIFY USER EXISTS
        const [user] = await conn.onWhatsApp(userJid).catch(() => []);
        if (!user?.exists) return reply("‚ùå User not found on WhatsApp");

        // 3. GET PROFILE PICTURE
        let ppUrl;
        try {
            ppUrl = await conn.profilePictureUrl(userJid, 'image');
        } catch {
            ppUrl = 'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png';
        }

        // 4. GET NAME (MULTI-SOURCE FALLBACK)
        let userName = userJid.split('@')[0];
        try {
            // Try group participant info first
            if (isGroup) {
                const member = participants.find(p => p.id === userJid);
                if (member?.notify) userName = member.notify;
            }
            
            // Try contact DB
            if (userName === userJid.split('@')[0] && conn.contactDB) {
                const contact = await conn.contactDB.get(userJid).catch(() => null);
                if (contact?.name) userName = contact.name;
            }
            
            // Try presence as final fallback
            if (userName === userJid.split('@')[0]) {
                const presence = await conn.presenceSubscribe(userJid).catch(() => null);
                if (presence?.pushname) userName = presence.pushname;
            }
        } catch (e) {
            console.log("Name fetch error:", e);
        }

        // 5. GET BIO/ABOUT
        let bio = {};
        try {
            // Try personal status
            const statusData = await conn.fetchStatus(userJid).catch(() => null);
            if (statusData?.status) {
                bio = {
                    text: statusData.status,
                    type: "Personal",
                    updated: statusData.setAt ? new Date(statusData.setAt * 1000) : null
                };
            } else {
                // Try business profile
                const businessProfile = await conn.getBusinessProfile(userJid).catch(() => null);
                if (businessProfile?.description) {
                    bio = {
                        text: businessProfile.description,
                        type: "Business",
                        updated: null
                    };
                }
            }
        } catch (e) {
            console.log("Bio fetch error:", e);
        }

        // 6. GET GROUP ROLE
        let groupRole = "";
        if (isGroup) {
            const participant = participants.find(p => p.id === userJid);
            groupRole = participant?.admin ? "üëë Admin" : "üë• Member";
        }

        // 7. FORMAT OUTPUT
        const formattedBio = bio.text ? 
            `${bio.text}\n‚îî‚îÄ üìå ${bio.type} Bio${bio.updated ? ` | üïí ${bio.updated.toLocaleString()}` : ''}` : 
            "No bio available";

        const userInfo = `
*GC MEMBER INFORMATION üßä*

üìõ *Name:* ${userName}
üî¢ *Number:* ${userJid.replace(/@.+/, '')}
üìå *Account Type:* ${user.isBusiness ? "üíº Business" : user.isEnterprise ? "üè¢ Enterprise" : "üë§ Personal"}

*üìù About:*
${formattedBio}

*‚öôÔ∏è Account Info:*
‚úÖ Registered: ${user.isUser ? "Yes" : "No"}
üõ°Ô∏è Verified: ${user.verifiedName ? "‚úÖ Verified" : "‚ùå Not verified"}
${isGroup ? `üë• *Group Role:* ${groupRole}` : ''}
`.trim();

        // 8. SEND RESULT
        await conn.sendMessage(from, {
            image: { url: ppUrl },
            caption: userInfo,
            mentions: [userJid]
        }, { quoted: mek });

    } catch (e) {
        console.error("Person command error:", e);
        reply(`‚ùå Error: ${e.message || "Failed to fetch profile"}`);
    }
});
                     
cmd({
    pattern: "msg",
    desc: "Send a message multiple times (Owner Only)",
    category: "group",
    react: "üîÅ",
    filename: __filename
},
async (conn, mek, m, { from, reply, isCreator, q }) => {
    // Owner-only restriction
    if (!isCreator) return reply('üö´ *Owner only command!*');

    try {
        // Check format: .msg text,count
        if (!q.includes(',')) {
            return reply("‚ùå *Format:* .msg text,count\n*Example:* .msg Hello,5");
        }

        const [message, countStr] = q.split(',');
        const count = parseInt(countStr.trim());

        // Hard limit: 1-100 messages
        if (isNaN(count) || count < 1 || count > 100) {
            return reply("‚ùå *Max 100 messages at once!*");
        }

        // Silent execution (no confirmations)
        for (let i = 0; i < count; i++) {
            await conn.sendMessage(from, { text: message }, { quoted: null });
            if (i < count - 1) await new Promise(resolve => setTimeout(resolve, 500)); // 500ms delay
        }

    } catch (e) {
        console.error("Error in msg command:", e);
        reply(`‚ùå *Error:* ${e.message}`);
    }
});

cmd({
    pattern: "report",
    alias: ["ask", "bug", "request"],
    desc: "Report a bug or request a feature",
    category: "group",
    filename: __filename
}, async (conn, mek, m, {
    from, body, command, args, senderNumber, reply
}) => {
    try {
        const botOwner = conn.user.id.split(":")[0]; // Extract the bot owner's number
        if (senderNumber !== botOwner) {
            return reply("Only the bot owner can use this command.");
        }
        
        if (!args.length) {
            return reply(`Example: ${config.PREFIX}report Play command is not working`);
        }

        const reportedMessages = {};
        const devNumber = "258871168283"; // Bot owner's number
        const messageId = m.key.id;

        if (reportedMessages[messageId]) {
            return reply("This report has already been forwarded to the owner. Please wait for a response.");
        }
        reportedMessages[messageId] = true;

        const reportText = `*| REQUEST/BUG |*\n\n*User*: @${m.sender.split("@")[0]}\n*Request/Bug*: ${args.join(" ")}`;
        const confirmationText = `Hi ${m.pushName}, your request has been forwarded to the owner. Please wait...`;

        await conn.sendMessage(`${devNumber}@s.whatsapp.net`, {
            text: reportText,
            mentions: [m.sender]
        }, { quoted: m });

        reply(confirmationText);
    } catch (error) {
        console.error(error);
        reply("An error occurred while processing your report.");
    }
});
 

cmd(
  {
    pattern: 'vsticker',
    alias: ['gsticker', 'g2s', 'gs', 's', 'vs',],
    desc: 'Convert GIF/Video to a sticker.',
    category: 'convert',
    use: '<reply media or URL>',
    filename: __filename,
  },
  async (conn, mek, m, { quoted, args, reply }) => {
    try {
      if (!mek.quoted) return reply('*Reply to a video or GIF to convert it to a sticker!*');

      const mime = mek.quoted.mtype;
      if (!['videoMessage', 'imageMessage'].includes(mime)) {
        return reply('*Please reply to a valid video or GIF.*');
      }

      // Download the media file
      const media = await mek.quoted.download();

      // Convert the video to a WebP buffer
      const webpBuffer = await videoToWebp(media);

      // Generate sticker metadata
      const sticker = new Sticker(webpBuffer, {
        pack: config.STICKER_NAME || 'My Pack',
        author: '·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢', // Leave blank or customize
        type: StickerTypes.FULL, // FULL for regular stickers
        categories: ['ü§©', 'üéâ'], // Emoji categories
        id: '12345', // Optional ID
        quality: 75, // Set quality for optimization
        background: 'transparent', // Transparent background
      });

      // Convert sticker to buffer and send
      const stickerBuffer = await sticker.toBuffer();
      return conn.sendMessage(mek.chat, { sticker: stickerBuffer }, { quoted: mek });
    } catch (error) {
      console.error(error);
      reply(`‚ùå An error occurred: ${error.message}`);
    }
  }
);    


cmd({
    pattern: "attp",
    desc: "Convert text to a GIF sticker.",
    react: "‚ú®",
    category: "convert",
    use: ".attp HI",
    filename: __filename,
}, async (conn, mek, m, { args, reply }) => {
    try {
        if (!args[0]) return reply("*Please provide text!*");

        const gifBuffer = await fetchGif(`https://api-fix.onrender.com/api/maker/attp?text=${encodeURIComponent(args[0])}`);
        const stickerBuffer = await gifToSticker(gifBuffer);

        await conn.sendMessage(m.chat, { sticker: stickerBuffer }, { quoted: mek });
    } catch (error) {
        reply(`‚ùå ${error.message}`);
    }
});

cmd({
    pattern: "tempmail",
    alias: ["genmail"],
    desc: "Generate a new temporary email address",
    category: "search",
    react: "üìß",
    filename: __filename
},
async (conn, mek, m, { from, reply, prefix }) => {
    try {
        const response = await axios.get('https://apis.davidcyriltech.my.id/temp-mail');
        const { email, session_id, expires_at } = response.data;

        // Format the expiration time and date
        const expiresDate = new Date(expires_at);
        const timeString = expiresDate.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        });
        const dateString = expiresDate.toLocaleDateString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric',
            year: 'numeric'
        });

        // Create the complete message
        const message = `
üìß *TEMPORARY EMAIL GENERATED*

‚úâÔ∏è *Email Address:*
${email}

‚è≥ *Expires:*
${timeString} ‚Ä¢ ${dateString}

üîë *Session ID:*
\`\`\`${session_id}\`\`\`

üì• *Check Inbox:*
.inbox ${session_id}

_Email will expire after 24 hours_
`;

        await conn.sendMessage(
            from,
            { 
                text: message,
                contextInfo: {
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363402829832961@newsletter',
                        newsletterName: 'TempMail Service',
                        serverMessageId: 101
                    }
                }
            },
            { quoted: mek }
        );

    } catch (e) {
        console.error('TempMail error:', e);
        reply(`‚ùå Error: ${e.message}`);
    }
});
cmd({
    pattern: "checkmail",
    alias: ["inbox", "tmail", "mailinbox"],
    desc: "Check your temporary email inbox",
    category: "search",
    react: "üì¨",
    filename: __filename
},
async (conn, mek, m, { from, reply, args }) => {
    try {
        const sessionId = args[0];
        if (!sessionId) return reply('üîë Please provide your session ID\nExample: .checkmail YOUR_SESSION_ID');

        const inboxUrl = `https://apis.davidcyriltech.my.id/temp-mail/inbox?id=${encodeURIComponent(sessionId)}`;
        const response = await axios.get(inboxUrl);

        if (!response.data.success) {
            return reply('‚ùå Invalid session ID or expired email');
        }

        const { inbox_count, messages } = response.data;

        if (inbox_count === 0) {
            return reply('üì≠ Your inbox is empty');
        }

        let messageList = `üì¨ *You have ${inbox_count} message(s)*\n\n`;
        messages.forEach((msg, index) => {
            messageList += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                          `üìå *Message ${index + 1}*\n` +
                          `üë§ *From:* ${msg.from}\n` +
                          `üìù *Subject:* ${msg.subject}\n` +
                          `‚è∞ *Date:* ${new Date(msg.date).toLocaleString()}\n\n` +
                          `üìÑ *Content:*\n${msg.body}\n\n`;
        });

        await reply(messageList);

    } catch (e) {
        console.error('CheckMail error:', e);
        reply(`‚ùå Error checking inbox: ${e.response?.data?.message || e.message}`);
    }
});
                                      
cmd({
  'pattern': "tourl",
  'alias': ["imgtourl", "imgurl", "url", "geturl", "upload"],
  'react': 'üñá',
  'desc': "Convert media to Catbox URL",
  'category': "convert",
  'use': ".tourl [reply to media]",
  'filename': __filename
}, async (client, message, args, { reply }) => {
  try {
    // Check if quoted message exists and has media
    const quotedMsg = message.quoted ? message.quoted : message;
    const mimeType = (quotedMsg.msg || quotedMsg).mimetype || '';
    
    if (!mimeType) {
      throw "Please reply to an image, video, or audio file";
    }

    // Download the media
    const mediaBuffer = await quotedMsg.download();
    const tempFilePath = path.join(os.tmpdir(), `catbox_upload_${Date.now()}`);
    fs.writeFileSync(tempFilePath, mediaBuffer);

    // Get file extension based on mime type
    let extension = '';
    if (mimeType.includes('image/jpeg')) extension = '.jpg';
    else if (mimeType.includes('image/png')) extension = '.png';
    else if (mimeType.includes('video')) extension = '.mp4';
    else if (mimeType.includes('audio')) extension = '.mp3';
    
    const fileName = `file${extension}`;

    // Prepare form data for Catbox
    const form = new FormData();
    form.append('fileToUpload', fs.createReadStream(tempFilePath), fileName);
    form.append('reqtype', 'fileupload');

    // Upload to Catbox
    const response = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders()
    });

    if (!response.data) {
      throw "Error uploading to Catbox";
    }

    const mediaUrl = response.data;
    fs.unlinkSync(tempFilePath);

    // Determine media type for response
    let mediaType = 'File';
    if (mimeType.includes('image')) mediaType = 'Image';
    else if (mimeType.includes('video')) mediaType = 'Video';
    else if (mimeType.includes('audio')) mediaType = 'Audio';

    // Send response
    await reply(
      `*${mediaType} Uploaded Successfully*\n\n` +
      `*Size:* ${formatBytes(mediaBuffer.length)}\n` +
      `*URL:* ${mediaUrl}\n\n` +
      `> ¬© Uploaded by 03:40MN üíú`
    );

  } catch (error) {
    console.error(error);
    await reply(`Error: ${error.message || error}`);
  }
});

// Helper function to format bytes
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
                      
cmd({
    pattern: "aivoice",
    alias: ["vai", "voicex", "voiceai"],
    desc: "Text to speech with different AI voices",
    category: "group",
    react: "ü™É",
    filename: __filename
},
async (conn, mek, m, { 
    from, 
    quoted, 
    body, 
    isCmd, 
    command, 
    args, 
    q, 
    isGroup, 
    sender, 
    senderNumber, 
    botNumber2, 
    botNumber, 
    pushname, 
    isMe, 
    isOwner, 
    groupMetadata, 
    groupName, 
    participants, 
    groupAdmins, 
    isBotAdmins, 
    isAdmins, 
    reply 
}) => {
    try {
        // Check if args[0] exists (user provided text)
        if (!args[0]) {
            return reply("Please provide text after the command.\nExample: .aivoice hello");
        }

        // Get the full input text
        const inputText = args.join(' ');

        // Send initial reaction
        await conn.sendMessage(from, {  
            react: { text: '‚è≥', key: m.key }  
        });

        // Voice model menu
        const voiceModels = [
            { number: "1", name: "Hatsune Miku", model: "miku" },
            { number: "2", name: "Nahida (Exclusive)", model: "nahida" },
            { number: "3", name: "Nami", model: "nami" },
            { number: "4", name: "Ana (Female)", model: "ana" },
            { number: "5", name: "Optimus Prime", model: "optimus_prime" },
            { number: "6", name: "Goku", model: "goku" },
            { number: "7", name: "Taylor Swift", model: "taylor_swift" },
            { number: "8", name: "Elon Musk", model: "elon_musk" },
            { number: "9", name: "Mickey Mouse", model: "mickey_mouse" },
            { number: "10", name: "Kendrick Lamar", model: "kendrick_lamar" },
            { number: "11", name: "Angela Adkinsh", model: "angela_adkinsh" },
            { number: "12", name: "Eminem", model: "eminem" }
        ];

        // Create menu text
        let menuText = "‚ï≠‚îÅ‚îÅ‚îÅ„Äî *QUEEN ELISA AI VOICE MODELS* „Äï‚îÅ‚îÅ‚îÅ‚ä∑\n";
        voiceModels.forEach(model => {
            menuText += `‚îÉ‚ñ∏ ${model.number}. ${model.name}\n`;
        });
        menuText += "‚ï∞‚îÅ‚îÅ‚îÅ‚™º\n\n";
        menuText += `üìå *Reply with the number to select voice model for:*\n"${inputText}"`;

        // Send menu message with image
        const sentMsg = await conn.sendMessage(from, {  
            image: { url: "https://files.catbox.moe/b477kp.jpg" },
            caption: menuText
        }, { quoted: m });

        const messageID = sentMsg.key.id;
        let handlerActive = true;

        // Set timeout to remove handler after 2 minutes
        const handlerTimeout = setTimeout(() => {
            handlerActive = false;
            conn.ev.off("messages.upsert", messageHandler);
            reply("‚åõ Voice selection timed out. Please try the command again.");
        }, 120000);

        // Message handler function
        const messageHandler = async (msgData) => {  
            if (!handlerActive) return;
            
            const receivedMsg = msgData.messages[0];  
            if (!receivedMsg || !receivedMsg.message) return;  

            const receivedText = receivedMsg.message.conversation || 
                              receivedMsg.message.extendedTextMessage?.text || 
                              receivedMsg.message.buttonsResponseMessage?.selectedButtonId;  
            const senderID = receivedMsg.key.remoteJid;  
            const isReplyToBot = receivedMsg.message.extendedTextMessage?.contextInfo?.stanzaId === messageID;  

            if (isReplyToBot && senderID === from) {  
                clearTimeout(handlerTimeout);
                conn.ev.off("messages.upsert", messageHandler);
                handlerActive = false;

                await conn.sendMessage(senderID, {  
                    react: { text: '‚¨áÔ∏è', key: receivedMsg.key }  
                });  

                const selectedNumber = receivedText.trim();
                const selectedModel = voiceModels.find(model => model.number === selectedNumber);

                if (!selectedModel) {
                    return reply("‚ùå Invalid option! Please reply with a number from the menu.");
                }

                try {
                    // Show processing message
                    await conn.sendMessage(from, {  
                        text: `üîä Generating audio with ${selectedModel.name} voice...`  
                    }, { quoted: receivedMsg });

                    // Call the API
                    const apiUrl = `https://api.agatz.xyz/api/voiceover?text=${encodeURIComponent(inputText)}&model=${selectedModel.model}`;
                    const response = await axios.get(apiUrl, {
                        timeout: 30000 // 30 seconds timeout
                    });
                    
                    const data = response.data;

                    if (data.status === 200) {
                        await conn.sendMessage(from, {  
                            audio: { url: data.data.oss_url },  
                            mimetype: "audio/mpeg"
                            // Removed ptt: true to send as regular audio
                        }, { quoted: receivedMsg });
                    } else {
                        reply("‚ùå Error generating audio. Please try again.");
                    }
                } catch (error) {
                    console.error("API Error:", error);
                    reply("‚ùå Error processing your request. Please try again.");
                }
            }  
        };

        // Register the handler
        conn.ev.on("messages.upsert", messageHandler);

    } catch (error) {
        console.error("Command Error:", error);
        reply("‚ùå An error occurred. Please try again.");
    }
});
                     
cmd({
  pattern: "wikipedia",
  alias: ["wiki"],
  react: "üìñ",
  desc: "Fetch Wikipedia information and translate to English.",
  category: "search",
  filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, reply }) => {
  try {
    if (!q) {
      return reply("Please provide a search query for Wikipedia.");
    }

    await reply("Searching Wikipedia...");

    const response = await fetchJson(`https://api.siputzx.my.id/api/s/wikipedia?query=${encodeURIComponent(q)}`);

    if (!response.status || !response.data) {
      return reply("No results found for your query.");
    }

    const { wiki, thumb } = response.data;

    // Translate the Wikipedia text to English
    const translated = await translate(wiki, { to: "en" });

    let message = `üìñ *Wikipedia Result*\n\nüìù *Query:* ${q}\n\n${translated.text}`;

    if (thumb) {
      await conn.sendMessage(m.chat, {
        image: { url: thumb },
        caption: message
      });
    } else {
      await reply(message);
    }

  } catch (error) {
    console.error(error);
    reply("An error occurred: " + error.message);
  }
});
cmd({
    pattern: "wstalk",
    alias: ["channelstalk", "chinfo"],
    desc: "Get WhatsApp channel information",
    category: "search",
    react: "üîç",
    filename: __filename
},
async (conn, mek, m, { from, reply, args }) => {
    try {
        // Check if URL is provided
        if (!args) return reply("‚ùå Please provide a WhatsApp channel URL\nExample: .wstalk https://whatsapp.com/channel/0029VatOy2EAzNc2WcShQw1j");

        // Extract channel ID from URL
        const channelId = args.match(/channel\/([0-9A-Za-z]+)/i)?.[1];
        if (!channelId) return reply("‚ùå Invalid WhatsApp channel URL");

        // API endpoint
        const apiUrl = `https://itzpire.com/stalk/whatsapp-channel?url=https://whatsapp.com/channel/${channelId}`;

        // Fetch channel info
        const response = await axios.get(apiUrl);
        const data = response.data.data;

        // Format the information
        const channelInfo = `‚ï≠‚îÅ‚îÅ„Äî *CHANNEL INFO* „Äï‚îÅ‚îÅ‚îà‚ä∑
‚îÉ‚óà‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ¬∑‡πè
‚îÉ‚óà‚îÉ‚Ä¢ *üì¢ Title*: ${data.title}
‚îÉ‚óà‚îÉ‚Ä¢ *üë• Followers*: ${data.followers}
‚îÉ‚óà‚îÉ‚Ä¢ *üìù Description*: ${data.description.replace(/\n/g, '\n‚îÉ‚óà‚îÉ‚Ä¢ ')}
‚îÉ‚óà‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îà‚ä∑
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îà‚ä∑
> ¬© ·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è ·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢`;

        // Send message with channel image
        await conn.sendMessage(from, {
            image: { url: data.img },
            caption: channelInfo,
            contextInfo: {
                forwardingScore: 999,
                isForwarded: true
            }
        }, { quoted: mek });

    } catch (e) {
        console.error("Error in wstalk command:", e);
        reply(`‚ùå Error: ${e.response?.data?.message || e.message}`);
    }
});


cmd({
  pattern: "joke",
  desc: "üòÇ Get a random joke",
  react: "ü§£",
  category: "group",
  filename: __filename
}, async (conn, m, store, { reply }) => {
  try {
    const response = await axios.get("https://official-joke-api.appspot.com/random_joke");
    const joke = response.data;

    if (!joke || !joke.setup || !joke.punchline) {
      return reply("‚ùå Failed to fetch a joke. Please try again.");
    }

    const jokeMessage = `ü§£ *Here's a random joke for you!* ü§£\n\n*${joke.setup}*\n\n${joke.punchline} üòÜ\n\n> *¬© Powered by ·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢*`;

    return reply(jokeMessage);
  } catch (error) {
    console.error("‚ùå Error in joke command:", error);
    return reply("‚ö†Ô∏è An error occurred while fetching the joke. Please try again.");
  }
});

// flirt

cmd({
    pattern: "flirt",
    alias: ["masom", "line"],
    desc: "Get a random flirt or pickup line.",
    react: "üíò",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        // Define API key and URL
        const shizokeys = 'shizo';
        const apiUrl = `https://shizoapi.onrender.com/api/texts/flirt?apikey=${shizokeys}`;

        // Fetch data from the API
        const res = await fetch(apiUrl);
        if (!res.ok) {
            throw new Error(`API error: ${await res.text()}`);
        }
        
        const json = await res.json();
        if (!json.result) {
            throw new Error("Invalid response from API.");
        }

        // Extract and send the flirt message
        const flirtMessage = `${json.result}`;
        await conn.sendMessage(from, {
            text: flirtMessage,
            mentions: [m.sender],
        }, { quoted: m });

    } catch (error) {
        console.error("Error in flirt command:", error);
        reply("Sorry, something went wrong while fetching the flirt line. Please try again later.");
    }
});

//truth

cmd({
    pattern: "truth",
    alias: ["truthquestion"],
    desc: "Get a random truth question from the API.",
    react: "‚ùì",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        const shizokeys = 'shizo';
        const res = await fetch(`https://shizoapi.onrender.com/api/texts/truth?apikey=${shizokeys}`);
        
        if (!res.ok) {
            console.error(`API request failed with status ${res.status}`);
            throw new Error(`API request failed with status ${res.status}`);
        }

        const json = await res.json();

        if (!json.result) {
            console.error("Invalid API response: No 'result' field found.");
            throw new Error("Invalid API response: No 'result' field found.");
        }

        const truthText = `${json.result}`;
        await conn.sendMessage(from, { 
            text: truthText, 
            mentions: [m.sender] 
        }, { quoted: m });

    } catch (error) {
        console.error("Error in truth command:", error);
        reply("Sorry, something went wrong while fetching the truth question. Please try again later.");
    }
});

// dare

cmd({
    pattern: "dare",
    alias: ["truthordare"],
    desc: "Get a random dare from the API.",
    react: "üéØ",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        // API Key
        const shizokeys = 'shizo';

        // Fetch dare text from the API
        const res = await fetch(`https://shizoapi.onrender.com/api/texts/dare?apikey=${shizokeys}`);
        
        if (!res.ok) {
            console.error(`API request failed with status ${res.status}`);
            throw new Error(`API request failed with status ${res.status}`);
        }

        const json = await res.json();

        if (!json.result) {
            console.error("Invalid API response: No 'result' field found.");
            throw new Error("Invalid API response: No 'result' field found.");
        }

        // Format the dare message
        const dareText = `${json.result}`;

        // Send the dare to the chat
        await conn.sendMessage(from, { 
            text: dareText, 
            mentions: [m.sender] 
        }, { quoted: m });

    } catch (error) {
        console.error("Error in dare command:", error);
        reply("Sorry, something went wrong while fetching the dare. Please try again later.");
    }
});

cmd({
  pattern: "fact",
  desc: "üß† Get a random fun fact",
  react: "üß†",
  category: "group",
  filename: __filename
}, async (conn, m, store, { reply }) => {
  try {
    const response = await axios.get("https://uselessfacts.jsph.pl/random.json?language=en");
    const fact = response.data.text;

    if (!fact) {
      return reply("‚ùå Failed to fetch a fun fact. Please try again.");
    }

    const factMessage = `üß† *Random Fun Fact* üß†\n\n${fact}\n\nIsn't that interesting? üòÑ\n\n> *¬© Powered by ·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢*`;

    return reply(factMessage);
  } catch (error) {
    console.error("‚ùå Error in fact command:", error);
    return reply("‚ö†Ô∏è An error occurred while fetching a fun fact. Please try again later.");
  }
});

cmd({
    pattern: "pickupline",
    alias: ["pickup"],
    desc: "Get a random pickup line from the API.",
    react: "üí¨",
    category: "group",
    filename: __filename,
}, 
async (conn, mek, m, { from, reply }) => {
    try {
        // Fetch pickup line from the API
        const res = await fetch('https://api.popcat.xyz/pickuplines');
        
        if (!res.ok) {
            throw new Error(`API request failed with status ${res.status}`);
        }

        const json = await res.json();

        // Log the API response (for debugging purposes)
        console.log('JSON response:', json);

        // Format the pickup line message
        const pickupLine = `*Here's a pickup line for you:*\n\n"${json.pickupline}"\n\n> *¬© Powered By 03:40MN*`;

        // Send the pickup line to the chat
        await conn.sendMessage(from, { text: pickupLine }, { quoted: m });

    } catch (error) {
        console.error("Error in pickupline command:", error);
        reply("Sorry, something went wrong while fetching the pickup line. Please try again later.");
    }
});

// char

cmd({
    pattern: "character",
    alias: ["char"],
    desc: "Check the character of a mentioned user.",
    react: "üî•",
    category: "convert",
    filename: __filename,
}, 
async (conn, mek, m, { from, isGroup, text, reply }) => {
    try {
        // Ensure the command is used in a group
        if (!isGroup) {
            return reply("This command can only be used in groups.");
        }

        // Extract the mentioned user
        const mentionedUser = m.message.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
        if (!mentionedUser) {
            return reply("Please mention a user whose character you want to check.");
        }

        // Define character traits
        const userChar = [
            "Sigma",
            "Generous",
            "Grumpy",
            "Overconfident",
            "Obedient",
            "Good",
            "Simp",
            "Kind",
            "Patient",
            "Pervert",
            "Cool",
            "Helpful",
            "Brilliant",
            "Sexy",
            "Hot",
            "Gorgeous",
            "Cute",
        ];

        // Randomly select a character trait
        const userCharacterSelection =
            userChar[Math.floor(Math.random() * userChar.length)];

        // Message to send
        const message = `Character of @${mentionedUser.split("@")[0]} is *${userCharacterSelection}* üî•‚ö°`;

        // Send the message with mentions
        await conn.sendMessage(from, {
            text: message,
            mentions: [mentionedUser],
        }, { quoted: m });

    } catch (e) {
        console.error("Error in character command:", e);
        reply("An error occurred while processing the command. Please try again.");
    }
});

cmd({
  pattern: "repeat",
  alias: ["rp", "rpm"],
  desc: "Repeat a message a specified number of times.",
  category: "group",
  filename: __filename
}, async (conn, m, store, { args, reply }) => {
  try {
    if (!args[0]) {
      return reply("‚ú≥Ô∏è Use this command like:\n*Example:* .repeat 10,I love you");
    }

    const [countStr, ...messageParts] = args.join(" ").split(",");
    const count = parseInt(countStr.trim());
    const message = messageParts.join(",").trim();

    if (isNaN(count) || count <= 0 || count > 300) {
      return reply("‚ùé Please specify a valid number between 1 and 300.");
    }

    if (!message) {
      return reply("‚ùé Please provide a message to repeat.");
    }

    const repeatedMessage = Array(count).fill(message).join("\n");

    reply(`üîÑ Repeated ${count} times:\n\n${repeatedMessage}`);
  } catch (error) {
    console.error("‚ùå Error in repeat command:", error);
    reply("‚ùé An error occurred while processing your request.");
  }
});

cmd({
  pattern: "send",
  desc: "Send a message multiple times, one by one.",
  category: "owner",
  filename: __filename
}, async (conn, m, store, { args, reply, senderNumber }) => {
  try {
    const botOwner = conn.user.id.split(":")[0]; // Get bot owner's number

    if (senderNumber !== botOwner) {
      return reply("‚ùé Only the bot owner can use this command.");
    }

    if (!args[0]) {
      return reply("‚ú≥Ô∏è Use this command like:\n *Example:* .send 10,I love you");
    }

    const [countStr, ...messageParts] = args.join(" ").split(",");
    const count = parseInt(countStr.trim());
    const message = messageParts.join(",").trim();

    if (isNaN(count) || count <= 0 || count > 100) {
      return reply("‚ùé Please specify a valid number between 1 and 100.");
    }

    if (!message) {
      return reply("‚ùé Please provide a message to send.");
    }

    reply(`‚è≥ Sending "${message}" ${count} times. This may take a while...`);

    for (let i = 0; i < count; i++) {
      await conn.sendMessage(m.from, { text: message }, { quoted: m });
      await sleep(1000); // 1-second delay
    }

    reply(`‚úÖ Successfully sent the message ${count} times.`);
  } catch (error) {
    console.error("‚ùå Error in ask command:", error);
    reply("‚ùé An error occurred while processing your request.");
  }
});

cmd({
  pattern: "readmore",
  alias: ["rm", "rmore", "readm"],
  desc: "Generate a Read More message.",
  category: "convert",
  use: ".readmore <text>",
  react: "üìù",
  filename: __filename
}, async (conn, m, store, { args, reply }) => {
  try {
    const inputText = args.join(" ") || "No text provided.";
    const readMore = String.fromCharCode(8206).repeat(4000); // Creates a large hidden gap
    const message = `${inputText} ${readMore} Continue Reading...`;

    await conn.sendMessage(m.from, { text: message }, { quoted: m });
  } catch (error) {
    console.error("‚ùå Error in readmore command:", error);
    reply("‚ùå An error occurred: " + error.message);
  }
});
cmd({
    pattern: "privacy",
    alias: ["privacymenu"],
    desc: "Privacy settings menu",
    category: "owner",
    react: "üîê",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let privacyMenu = `‚ï≠‚îÅ‚îÅ„Äî *Privacy Settings* „Äï‚îÅ‚îÅ‚îà‚ä∑
‚îÉ‚óà‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ¬∑‡πè
‚îÉ‚óà‚îÉ‚Ä¢ blocklist - View blocked users
‚îÉ‚óà‚îÉ‚Ä¢ getbio - Get user's bio
‚îÉ‚óà‚îÉ‚Ä¢ setppall - Set profile pic privacy
‚îÉ‚óà‚îÉ‚Ä¢ setonline - Set online privacy
‚îÉ‚óà‚îÉ‚Ä¢ setpp - Change bot's profile pic
‚îÉ‚óà‚îÉ‚Ä¢ setmyname - Change bot's name
‚îÉ‚óà‚îÉ‚Ä¢ updatebio - Change bot's bio
‚îÉ‚óà‚îÉ‚Ä¢ groupsprivacy - Set group add privacy
‚îÉ‚óà‚îÉ‚Ä¢ getprivacy - View current privacy settings
‚îÉ‚óà‚îÉ‚Ä¢ getpp - Get user's profile picture
‚îÉ‚óà‚îÉ
‚îÉ‚óà‚îÉ*Options for privacy commands:*
‚îÉ‚óà‚îÉ‚Ä¢ all - Everyone
‚îÉ‚óà‚îÉ‚Ä¢ contacts - My contacts only
‚îÉ‚óà‚îÉ‚Ä¢ contact_blacklist - Contacts except blocked
‚îÉ‚óà‚îÉ‚Ä¢ none - Nobody
‚îÉ‚óà‚îÉ‚Ä¢ match_last_seen - Match last seen
‚îÉ‚óà‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îà‚ä∑
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îà‚ä∑
*Note:* Most commands are owner-only`;

        await conn.sendMessage(
            from,
            {
                image: { url: `https://files.catbox.moe/v6zfno.jpg` }, // Replace with privacy-themed image if available
                caption: privacyMenu,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363402829832961@newsletter',
                        newsletterName: "Privacy Settings",
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

    } catch (e) {
        console.log(e);
        reply(`Error: ${e.message}`);
    }
});


cmd({
    pattern: "blocklist",
    desc: "View the list of blocked users.",
    category: "owner",
    react: "üìã",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply }) => {
    if (!isOwner) return reply("*üìõ You are not the owner!*");

    try {
        // Fetch the block list
        const blockedUsers = await conn.fetchBlocklist();

        if (blockedUsers.length === 0) {
            return reply("üìã Your block list is empty.");
        }

        // Format the blocked users with üìå and count the total
        const list = blockedUsers
            .map((user, i) => `üöß BLOCKED ${user.split('@')[0]}`) // Remove domain and add üìå
            .join('\n');

        const count = blockedUsers.length;
        reply(`üìã Blocked Users (${count}):\n\n${list}`);
    } catch (err) {
        console.error(err);
        reply(`‚ùå Failed to fetch block list: ${err.message}`);
    }
});

cmd({
    pattern: "getbio",
    desc: "Displays the user's bio.",
    category: "owner",
    filename: __filename,
}, async (conn, mek, m, { args, reply }) => {
    try {
        const jid = args[0] || mek.key.remoteJid;
        const about = await conn.fetchStatus?.(jid);
        if (!about) return reply("No bio found.");
        return reply(`User Bio:\n\n${about.status}`);
    } catch (error) {
        console.error("Error in bio command:", error);
        reply("No bio found.");
    }
});
cmd({
    pattern: "setppall",
    desc: "Update Profile Picture Privacy",
    category: "owner",
    react: "üîê",
    filename: __filename
}, 
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");
    
    try {
        const value = args[0] || 'all'; 
        const validValues = ['all', 'contacts', 'contact_blacklist', 'none'];  
        
        if (!validValues.includes(value)) {
            return reply("‚ùå Invalid option. Valid options are: 'all', 'contacts', 'contact_blacklist', 'none'.");
        }
        
        await conn.updateProfilePicturePrivacy(value);
        reply(`‚úÖ Profile picture privacy updated to: ${value}`);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});
cmd({
    pattern: "setonline",
    desc: "Update Online Privacy",
    category: "owner",
    react: "üîê",
    filename: __filename
}, 
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");

    try {
        const value = args[0] || 'all'; 
        const validValues = ['all', 'match_last_seen'];
        
        if (!validValues.includes(value)) {
            return reply("‚ùå Invalid option. Valid options are: 'all', 'match_last_seen'.");
        }

        await conn.updateOnlinePrivacy(value);
        reply(`‚úÖ Online privacy updated to: ${value}`);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "setpp",
    desc: "Set bot profile picture.",
    category: "owner",
    react: "üñºÔ∏è",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, quoted, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");
    if (!quoted || !quoted.message.imageMessage) return reply("‚ùå Please reply to an image.");
    try {
        const stream = await downloadContentFromMessage(quoted.message.imageMessage, 'image');
        let buffer = Buffer.from([]);
        for await (const chunk of stream) {
            buffer = Buffer.concat([buffer, chunk]);
        }

        const mediaPath = path.join(__dirname, `${Date.now()}.jpg`);
        fs.writeFileSync(mediaPath, buffer);

        // Update profile picture with the saved file
        await conn.updateProfilePicture(conn.user.jid, { url: `file://${mediaPath}` });
        reply("üñºÔ∏è Profile picture updated successfully!");
    } catch (error) {
        console.error("Error updating profile picture:", error);
        reply(`‚ùå Error updating profile picture: ${error.message}`);
    }
});

cmd({
    pattern: "setmyname",
    desc: "Set your WhatsApp display name.",
    category: "owner",
    react: "‚öôÔ∏è",
    filename: __filename
},
async (conn, mek, m, { from, isOwner, reply, args }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");

    // Ensure you have the display name argument
    const displayName = args.join(" ");
    if (!displayName) return reply("‚ùå Please provide a display name.");

    try {
        // Ensure the session is loaded before trying to update
        const { state, saveCreds } = await useMultiFileAuthState('path/to/auth/folder');
        const conn = makeWASocket({
            auth: state,
            printQRInTerminal: true,
        });

        conn.ev.on('creds.update', saveCreds);

        // Update display name after connection
        await conn.updateProfileName(displayName);
        reply(`‚úÖ Your display name has been set to: ${displayName}`);
    } catch (err) {
        console.error(err);
        reply("‚ùå Failed to set your display name.");
    }
});

cmd({
    pattern: "updatebio",
    react: "ü•è",
    desc: "Change the Bot number Bio.",
    category: "owner",
    use: '.updatebio',
    filename: __filename
},
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isOwner) return reply('üö´ *You must be an Owner to use this command*');
        if (!q) return reply('‚ùì *Enter the New Bio*');
        if (q.length > 139) return reply('‚ùó *Sorry! Character limit exceeded*');
        await conn.updateProfileStatus(q);
        await conn.sendMessage(from, { text: "‚úîÔ∏è *New Bio Added Successfully*" }, { quoted: mek });
    } catch (e) {
        reply('üö´ *An error occurred!*\n\n' + e);
        l(e);
    }
});
cmd({
    pattern: "groupsprivacy",
    desc: "Update Group Add Privacy",
    category: "owner",
    react: "üîê",
    filename: __filename
}, 
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    if (!isOwner) return reply("‚ùå You are not the owner!");

    try {
        const value = args[0] || 'all'; 
        const validValues = ['all', 'contacts', 'contact_blacklist', 'none'];
        
        if (!validValues.includes(value)) {
            return reply("‚ùå Invalid option. Valid options are: 'all', 'contacts', 'contact_blacklist', 'none'.");
        }

        await conn.updateGroupsAddPrivacy(value);
        reply(`‚úÖ Group add privacy updated to: ${value}`);
    } catch (e) {
        return reply(`*An error occurred while processing your request.*\n\n_Error:_ ${e.message}`);
    }
});

cmd({
    pattern: "getprivacy",
    desc: "Get the bot Number Privacy Setting Updates.",
    category: "owner",
    use: '.getprivacy',
    filename: __filename
},
async (conn, mek, m, { from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isOwner) return reply('üö´ *You must be an Owner to use this command*');
        const duka = await conn.fetchPrivacySettings?.(true);
        if (!duka) return reply('üö´ *Failed to fetch privacy settings*');
        
        let puka = `
‚ï≠‚îÄ‚îÄ‚îÄ„Äå ùôøùöÅùô∏ùöÖùô∞ùô≤ùöà  „Äç‚îÄ‚îÄ‚îÄ‚óÜ  
‚îÇ ‚àò ùöÅùöéùöäùöç ùöÅùöéùöåùöéùöíùöôùöù: ${duka.readreceipts}  
‚îÇ ‚àò ùôøùöõùöòùöèùöíùöïùöé ùôøùöíùöåùöùùöûùöõùöé: ${duka.profile}  
‚îÇ ‚àò ùöÇùöùùöäùöùùöûùöú: ${duka.status}  
‚îÇ ‚àò ùôæùöóùöïùöíùöóùöé: ${duka.online}  
‚îÇ ‚àò ùôªùöäùöúùöù ùöÇùöéùöéùöó: ${duka.last}  
‚îÇ ‚àò ùô∂ùöõùöòùöûùöô ùôøùöõùöíùöüùöäùöåùö¢: ${duka.groupadd}  
‚îÇ ‚àò ùô≤ùöäùöïùöï ùôøùöõùöíùöüùöäùöåùö¢: ${duka.calladd}  
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`;
        await conn.sendMessage(from, { text: puka }, { quoted: mek });
    } catch (e) {
        reply('üö´ *An error occurred!*\n\n' + e);
        l(e);
    }
});
cmd({
    pattern: "getpp",
    desc: "Fetch the profile picture of a tagged or replied user.",
    category: "owner",
    filename: __filename
}, async (conn, mek, m, { quoted, isGroup, sender, participants, reply }) => {
    try {
        // Determine the target user
        const targetJid = quoted ? quoted.sender : sender;

        if (!targetJid) return reply("‚ö†Ô∏è Please reply to a message to fetch the profile picture.");

        // Fetch the user's profile picture URL
        const userPicUrl = await conn.profilePictureUrl(targetJid, "image").catch(() => null);

        if (!userPicUrl) return reply("‚ö†Ô∏è No profile picture found for the specified user.");

        // Send the user's profile picture
        await conn.sendMessage(m.chat, {
            image: { url: userPicUrl },
            caption: "üñºÔ∏è Here is the profile picture of the specified user."
        });
    } catch (e) {
        console.error("Error fetching user profile picture:", e);
        reply("‚ùå An error occurred while fetching the profile picture. Please try again later.");
    }
});

cmd({
  pattern: "ss",
  alias: ["ssweb"],
  react: "üí´",
  desc: "Download screenshot of a given link.",
  category: "other",
  use: ".ss <link>",
  filename: __filename,
}, 
async (conn, mek, m, {
  from, l, quoted, body, isCmd, command, args, q, isGroup, sender, 
  senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, 
  groupMetadata, groupName, participants, isItzcp, groupAdmins, 
  isBotAdmins, isAdmins, reply 
}) => {
  if (!q) {
    return reply("Please provide a URL to capture a screenshot.");
  }

  try {
    // created by jawad tech 
    const response = await axios.get(`https://api.davidcyriltech.my.id/ssweb?url=${q}`);
    const screenshotUrl = response.data.screenshotUrl;

    // give credit and use
    const imageMessage = {
      image: { url: screenshotUrl },
      caption: "*WEB SS DOWNLOADER*\n\n> *¬© Powered By ·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢*",
      contextInfo: {
        mentionedJid: [m.sender],
        forwardingScore: 999,
        isForwarded: true,
        forwardedNewsletterMessageInfo: {
          newsletterJid: '120363402829832961@newsletter',
          newsletterName: "·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢",
          serverMessageId: 143,
        },
      },
    };

    await conn.sendMessage(from, imageMessage, { quoted: m });
  } catch (error) {
    console.error(error);
    reply("Failed to capture the screenshot. Please try again.");
  }
});

// ‚øª ‚åú ELISA ‚åü‚øªÕõ‚ÉÆüáµüá∞ñ§ê
cmd({
  pattern: "rw",
  alias: ["randomwall", "wallpaper"],
  react: "üåå",
  desc: "Download random wallpapers based on keywords.",
  category: "download",
  use: ".rw <keyword>",
  filename: __filename
}, async (conn, m, store, { from, args, reply }) => {
  try {
    const query = args.join(" ") || "random";
    const apiUrl = `https://pikabotzapi.vercel.app/random/randomwall/?apikey=anya-md&query=${encodeURIComponent(query)}`;

    const { data } = await axios.get(apiUrl);
    
    if (data.status && data.imgUrl) {
      const caption = `üåå *Random Wallpaper: ${query}*\n\n> *¬© Powered by ·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢*`;
      await conn.sendMessage(from, { image: { url: data.imgUrl }, caption }, { quoted: m });
    } else {
      reply(`‚ùå No wallpaper found for *"${query}"*.`);
    }
  } catch (error) {
    console.error("Wallpaper Error:", error);
    reply("‚ùå An error occurred while fetching the wallpaper. Please try again.");
  }
});
cmd({
    pattern: "weather",
    desc: "üå§ Get weather information for a location",
    react: "üå§",
    category: "group",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply("‚ùó Please provide a city name. Usage: .weather [city name]");
        const apiKey = '2d61a72574c11c4f36173b627f8cb177'; 
        const city = q;
        const url = `http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;
        const response = await axios.get(url);
        const data = response.data;
        const weather = `
> üåç *Weather Information for ${data.name}, ${data.sys.country}* üåç
> üå°Ô∏è *Temperature*: ${data.main.temp}¬∞C
> üå°Ô∏è *Feels Like*: ${data.main.feels_like}¬∞C
> üå°Ô∏è *Min Temp*: ${data.main.temp_min}¬∞C
> üå°Ô∏è *Max Temp*: ${data.main.temp_max}¬∞C
> üíß *Humidity*: ${data.main.humidity}%
> ‚òÅÔ∏è *Weather*: ${data.weather[0].main}
> üå´Ô∏è *Description*: ${data.weather[0].description}
> üí® *Wind Speed*: ${data.wind.speed} m/s
> üîΩ *Pressure*: ${data.main.pressure} hPa

> *¬© Powdered By ·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢*
`;
        return reply(weather);
    } catch (e) {
        console.log(e);
        if (e.response && e.response.status === 404) {
            return reply("üö´ City not found. Please check the spelling and try again.");
        }
        return reply("‚ö†Ô∏è An error occurred while fetching the weather information. Please try again later.");
    }
});
                 
cmd({
  pattern: "repo",
  desc: "Fetch information about a GitHub repository.",
  category: "group",
  react: "üçÉ",
  filename: __filename
}, async (conn, m, store, { from, args, reply }) => {
  try {
    const repoName = args.join(" ");
    if (!repoName) {
      return reply("‚ùå Please provide a GitHub repository in the format üìå `owner/repo`.");
    }

    const apiUrl = `https://api.github.com/repos/${repoName}`;
    const { data } = await axios.get(apiUrl);

    let responseMsg = `üìÅ *GitHub Repository Info* üìÅ\n\n`;
    responseMsg += `üìå *Name*: ${data.name}\n`;
    responseMsg += `üîó *URL*: ${data.html_url}\n`;
    responseMsg += `üìù *Description*: ${data.description || "No description"}\n`;
    responseMsg += `‚≠ê *Stars*: ${data.stargazers_count}\n`;
    responseMsg += `üç¥ *Forks*: ${data.forks_count}\n`;
    responseMsg += `üë§ *Owner*: ${data.owner.login}\n`;
    responseMsg += `üìÖ *Created At*: ${new Date(data.created_at).toLocaleDateString()}\n`;
    responseMsg += `\n> *¬© Powered by JawadTechX*`;

    await conn.sendMessage(from, { text: responseMsg }, { quoted: m });
  } catch (error) {
    console.error("GitHub API Error:", error);
    reply(`‚ùå Error fetching repository data: ${error.response?.data?.message || error.message}`);
  }
});
cmd({
  pattern: "quran",
  alias: ["surah"],
  react: "ü§ç",
  desc: "Get Quran Surah details and explanation.",
  category: "group",
  filename: __filename
}, async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
  try {

    let surahInput = args[0];

    if (!surahInput) {
      return reply('Type Surah Number or Type *.Surahmenu* for getting Surah numbers');
    }

    let surahListRes = await fetchJson('https://quran-endpoint.vercel.app/quran');
    let surahList = surahListRes.data;

    let surahData = surahList.find(surah => 
        surah.number === Number(surahInput) || 
        surah.asma.ar.short.toLowerCase() === surahInput.toLowerCase() || 
        surah.asma.en.short.toLowerCase() === surahInput.toLowerCase()
    );

    if (!surahData) {
      return reply(`Couldn't find surah with number or name "${surahInput}"`);
    }

    let res = await fetch(`https://quran-endpoint.vercel.app/quran/${surahData.number}`);
    
    if (!res.ok) {
      let error = await res.json(); 
      return reply(`API request failed with status ${res.status} and message ${error.message}`);
    }

    let json = await res.json();

    let translatedTafsirUrdu = await translate(json.data.tafsir.id, { to: 'ur', autoCorrect: true });

    let translatedTafsirEnglish = await translate(json.data.tafsir.id, { to: 'en', autoCorrect: true });

    let quranSurah = `
üïã *Quran: The Holy Book ‚ô•Ô∏èüåπŸÇÿ±ÿ¢ŸÜ ŸÖÿ¨€åÿØüåπ‚ô•Ô∏è*\n
üìñ *Surah ${json.data.number}: ${json.data.asma.ar.long} (${json.data.asma.en.long})*\n
üí´Type: ${json.data.type.en}\n
‚úÖNumber of verses: ${json.data.ayahCount}\n
‚ö°üîÆ *Explanation (Urdu):*\n
${translatedTafsirUrdu.text}\n
‚ö°üîÆ *Explanation (English):*\n
${translatedTafsirEnglish.text}`;

    await conn.sendMessage(
      from,
      {
        image: { url: `https://files.catbox.moe/v6zfno.jpg` },
        caption: quranSurah,
        contextInfo: {
          mentionedJid: [m.sender], 
          forwardingScore: 999,  
          isForwarded: true,   
          forwardedNewsletterMessageInfo: {
            newsletterJid: '120363402829832961@newsletter', 
            newsletterName: '·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢', 
            serverMessageId: 143
          }
        }
      },
      { quoted: mek }
    );

    if (json.data.recitation.full) {
      await conn.sendMessage(from, {
        audio: { url: json.data.recitation.full },
        mimetype: 'audio/mpeg',  
        ptt: true
      }, { quoted: mek });
    }

  } catch (error) {
    console.error(error);
    reply(`Error: ${error.message}`);
  }
});


cmd({
    pattern: "quranmenu",
    alias: ["surahmenu", "surahlist"],
    desc: "menu the bot",
    category: "owner",
    react: "‚ù§Ô∏è",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, body,isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        let dec = `‚ù§Ô∏è  ‚ä∑‚îà *QURAN KAREEM* ‚îà‚ä∑  ü§ç

 üí´ ùòàùò≠ùò≠ ùò¥ùò∂ùò≥ùò¢ùò© ùò¢ùòØùò• ùòµùò©ùò¶ùò™ùò≥ ùòØùò∂ùòÆùò£ùò¶ùò≥ùò¥ ùò≠ùò™ùò¥ùòµ
ùòßùò∞ùò≥ ùò®ùò¶ùòµùòµùò™ùòØùò® ùò¥ùò∂ùò≥ùò¢ùò© ùòµùò∫ùò±ùò¶ .ùò¥ùò∂ùò≥ùò¢ùò© 36 üí´üå∏ 

1. üïå Al-Fatiha (The Opening) - ÿßŸÑŸÅÿßÿ™ÿ≠€Å (Ÿæ€ÅŸÑÿß ÿ≥Ÿàÿ±€Å)


2. üêÑ Al-Baqarah (The Cow) - ÿßŸÑÿ®ŸÇÿ±€Å (⁄Øÿßÿ¶€í)


3. üè† Aali Imran (The Family of Imran) - ÿ¢ŸÑ ÿπŸÖÿ±ÿßŸÜ (ÿπŸÖÿ±ÿßŸÜ ⁄©ÿß ÿÆÿßŸÜÿØÿßŸÜ)


4. üë© An-Nisa' (The Women) - ÿßŸÑŸÜÿ≥ÿßÿ° (ÿπŸàÿ±ÿ™€å⁄∫)


5. üçΩÔ∏è Al-Ma'idah (The Table Spread) - ÿßŸÑŸÖÿßÿ¶ÿØ€Å (Ÿæ⁄æ€åŸÑ€å €ÅŸàÿ¶€å ŸÖ€åÿ≤)


6. üê™ Al-An'am (The Cattle) - ÿßŸÑÿßŸÜÿπÿßŸÖ (ŸÖŸà€åÿ¥€å)


7. ‚õ∞Ô∏è Al-A'raf (The Heights) - ÿßŸÑÿ£ÿπÿ±ÿßŸÅ (ÿ®ŸÑŸÜÿØ€åÿß⁄∫)


8. ‚öîÔ∏è Al-Anfal (The Spoils of War) - ÿßŸÑÿßŸÜŸÅÿßŸÑ (ÿ∫ŸÜÿßÿ¶ŸÖ)


9. üôè At-Tawbah (The Repentance) - ÿßŸÑÿ™Ÿàÿ®€Å (ÿ™Ÿàÿ®€Å)


10. üêü Yunus (Jonah) - €åŸàŸÜÿ≥ (€åŸàŸÜÿ≥)


11. üå©Ô∏è Hud (Hud) - €ÅŸàÿØ (€ÅŸàÿØ)


12. üë∂ Yusuf (Joseph) - €åŸàÿ≥ŸÅ (€åŸàÿ≥ŸÅ)


13. ‚ö° Ar-Rad (The Thunder) - ÿßŸÑÿ±ÿπÿØ (⁄Øÿ±ÿ¨)


14. üïäÔ∏è Ibrahim (Abraham) - ÿßÿ®ÿ±ÿß€Å€åŸÖ (ÿßÿ®ÿ±ÿß€Å€åŸÖ)


15. ü™® Al-Hijr (The Rocky Tract) - ÿßŸÑÿ≠ÿ¨ÿ± (Ÿæÿ™⁄æÿ±ÿßÿ¶€å ÿ≤ŸÖ€åŸÜ)


16. üêù An-Nahl (The Bee) - ÿßŸÑŸÜÿ≠ŸÑ (ŸÖ⁄©⁄æ€å)


17. üåô Al-Isra' (The Night Journey) - ÿßŸÑÿ•ÿ≥ÿ±ÿßÿ° (ÿ±ÿßÿ™ ⁄©ÿß ÿ≥ŸÅÿ±)


18. üï≥Ô∏è Al-Kahf (The Cave) - ÿßŸÑ⁄©€ÅŸÅ (ÿ∫ÿßÿ±)


19. üßïüèª Maryam (Mary) - ŸÖÿ±€åŸÖ (ŸÖÿ±€åŸÖ)


20. üìú Ta-Ha (Ta-Ha) - ÿ∑Ÿ∞€ÅŸ∞ (ÿ∑Ÿ∞€ÅŸ∞)


21. üìñ Al-Anbiya' (The Prophets) - ÿßŸÑÿßŸÜÿ®€åÿßÿ° (Ÿæ€åÿ∫ŸÖÿ®ÿ±Ÿà⁄∫)


22. üïã Al-Hajj (The Pilgrimage) - ÿßŸÑÿ≠ÿ¨ (ÿ≠ÿ¨)


23. üôå Al-Mu'minun (The Believers) - ÿßŸÑŸÖÿ§ŸÖŸÜŸàŸÜ (ÿß€åŸÖÿßŸÜ ŸàÿßŸÑ€í)


24. üí° An-Nur (The Light) - ÿßŸÑŸÜŸàÿ± (ÿ±Ÿàÿ¥ŸÜ€å)


25. ‚öñÔ∏è Al-Furqan (The Criterion) - ÿßŸÑŸÅÿ±ŸÇÿßŸÜ (ŸÅÿ±ŸÇ ⁄©ÿ±ŸÜ€í ŸàÿßŸÑÿß)


26. üé§ Ash-Shu'ara' (The Poets) - ÿßŸÑÿ¥ÿπÿ±ÿßÿ° (ÿ¥ÿßÿπÿ±)


27. üêú An-Naml (The Ant) - ÿßŸÑŸÜŸÖŸÑ (⁄Ü⁄ë€åÿß)


28. üìö Al-Qasas (The Stories) - ÿßŸÑŸÇÿµÿµ (⁄©€ÅÿßŸÜ€åÿß⁄∫)


29. üï∑Ô∏è Al-Ankabut (The Spider) - ÿßŸÑÿ£ŸÜÿπÿßŸÖ (ŸÖ⁄©⁄ë€å)


30. üèõÔ∏è Ar-Rum (The Romans) - ÿßŸÑÿ±ŸàŸÖ (ÿ±ŸàŸÖ€å)


31. üìñ Luqman (Luqman) - ŸÑŸÇŸÖÿßŸÜ (ŸÑŸÇŸÖÿßŸÜ)


32. üôá As-Sajda (The Prostration) - ÿßŸÑÿ≥ÿ¨ÿØ€Å (ÿ≥ÿ¨ÿØ€Å)


33. ‚öîÔ∏è Al-Ahzab (The Combined Forces) - ÿßŸÑÿßÿ≠ÿ≤ÿßÿ® (ŸÖÿÆŸÑŸàÿ∑ ŸÇŸàÿ™€å⁄∫)


34. üå∏ Saba' (Sheba) - ÿ≥ÿ®ÿß (ÿ≥ÿ®ÿß)


35. üõ†Ô∏è Fatir (The Originator) - ŸÅÿßÿ∑ÿ± (ÿÆÿßŸÑŸÇ)


36. üìñ Ya-Sin (Ya-Sin) - €åÿ≥ (€åÿ≥)


37. üõ°Ô∏è As-Saffat (Those who set the Ranks) - ÿßŸÑÿµÿßŸÅÿßÿ™ (ÿµŸÅ€å⁄∫ ŸÖÿ±ÿ™ÿ® ⁄©ÿ±ŸÜ€í ŸàÿßŸÑ€í)


38. üÖ±Ô∏è Sad (The Letter Sad) - ÿµÿßÿØ (ÿ≠ÿ±ŸÅ ÿµÿßÿØ)


39. ü™ñ Az-Zumar (The Troops) - ÿßŸÑÿ≤ŸÖÿ± (ÿ¨ŸÜ⁄Ø€å ÿØÿ≥ÿ™€í)


40. ü§≤ Ghafir (The Forgiver) - ÿ∫ÿßŸÅÿ± (ÿ®ÿÆÿ¥ŸÜ€í ŸàÿßŸÑÿß)


41. üìú Fussilat (Explained in Detail) - ŸÅÿµŸÑÿ™ (ÿ™ŸÅÿµ€åŸÑ ÿ≥€í ÿ®€åÿßŸÜ)


42. üó£Ô∏è Ash-Shura (Consultation) - ÿßŸÑÿ¥Ÿàÿ±€å (ŸÖÿ¥ÿßŸàÿ±ÿ™)


43. üí∞ Az-Zukhruf (The Gold Adornments) - ÿßŸÑÿ≤ÿÆÿ±ŸÅ (ÿ≥ŸàŸÜ€í ⁄©€í ÿ≤€åŸàÿ±)


44. üí® Ad-Dukhan (The Smoke) - ÿßŸÑÿØÿÆÿßŸÜ (ÿØ⁄æŸàÿß⁄∫)


45. üêä Al-Jathiyah (The Crouching) - ÿßŸÑÿ¨ÿßÿ´€å€Å (ÿ¨⁄æ⁄©ŸÜÿß)


46. üå™Ô∏è Al-Ahqaf (The Wind-Curved Sandhills) - ÿßŸÑÿ£ÿ≠ŸÇÿßŸÅ (€ÅŸàÿßÿ¶€å ⁄Ü⁄©ÿ±Ÿà⁄∫ ŸàÿßŸÑ€å ÿ±€åÿ™ ⁄©€å Ÿæ€Åÿß⁄ë€åÿß⁄∫)


47. üïã Muhammad (Muhammad) - ŸÖÿ≠ŸÖÿØ (ŸÖÿ≠ŸÖÿØ)


48. üèÜ Al-Fath (The Victory) - ÿßŸÑŸÅÿ™ÿ≠ (ŸÅÿ™ÿ≠)


49. üè† Al-Hujurat (The Rooms) - ÿßŸÑÿ≠ÿ¨ÿ±ÿßÿ™ (⁄©ŸÖÿ±€í)


50. üî§ Qaf (The Letter Qaf) - ŸÇÿßŸÅ (ÿ≠ÿ±ŸÅ ŸÇÿßŸÅ)


51. üå¨Ô∏è Adh-Dhariyat (The Winnowing Winds) - ÿßŸÑÿ∞ÿßÿ±€åÿßÿ™ (Ÿæ⁄æŸπŸÜ€í ŸàÿßŸÑ€å €ÅŸàÿßÿ¶€å⁄∫)


52. ‚õ∞Ô∏è At-Tur (The Mount) - ÿßŸÑÿ∑Ÿàÿ± (Ÿæ€Åÿß⁄ë)


53. üåü An-Najm (The Star) - ÿßŸÑŸÜÿ¨ŸÖ (ÿ≥ÿ™ÿßÿ±€Å)


54. üåô Al-Qamar (The Moon) - ÿßŸÑŸÇŸÖÿ± (⁄ÜÿßŸÜÿØ)


55. üíñ Ar-Rahman (The Beneficent) - ÿßŸÑÿ±ÿ≠ŸÖŸÜ (ÿ®€Åÿ™ ŸÖ€Åÿ±ÿ®ÿßŸÜ)


56. üåå Al-Waqi'a (The Inevitable) - ÿßŸÑŸàÿßŸÇÿπ€Å (€ÅŸàŸÜ€í ŸàÿßŸÑÿß)


57. üî© Al-Hadid (The Iron) - ÿßŸÑÿ≠ÿØ€åÿØ (ŸÑŸà€Åÿß)


58. üë©‚Äç‚öñÔ∏è Al-Mujadila (The Pleading Woman) - ÿßŸÑŸÖÿ¨ÿßÿØŸÑ€Å (ŸÖÿØÿπ€å ÿπŸàÿ±ÿ™)


59. üè¥ Al-Hashr (The Exile) - ÿßŸÑÿ≠ÿ¥ÿ± (ÿßÿÆÿ±ÿßÿ¨)


60. üîç Al-Mumtahanah (She that is to be examined) - ÿßŸÑŸÖŸÖÿ™ÿ≠ŸÜ€Å (ÿ¨ÿßŸÜ⁄ÜŸÜ€í ŸàÿßŸÑ€å)


61. üìä As-Saff (The Ranks) - ÿßŸÑÿµŸÅ (ÿµŸÅ€å⁄∫)


62. üïå Al-Jumu'ah (Friday) - ÿßŸÑÿ¨ŸÖÿπÿ© (ÿ¨ŸÖÿπ€Å)


63. ü§• Al-Munafiqun (The Hypocrites) - ÿßŸÑŸÖŸÜÿßŸÅŸÇŸàŸÜ (ŸÖŸÜÿßŸÅŸÇ)


64. üå™Ô∏è At-Taghabun (Mutual Disillusion) - ÿßŸÑÿ™ÿ∫ÿßÿ®ŸÜ (ÿ¢Ÿæÿ≥ ⁄©€å ÿ®€í ŸàŸÇŸàŸÅ€å)


65. üíî At-Talaq (The Divorce) - ÿßŸÑÿ∑ŸÑÿßŸÇ (ÿ∑ŸÑÿßŸÇ)


66. üö´ At-Tahrim (The Prohibition) - ÿßŸÑÿ™ÿ≠ÿ±€åŸÖ (Ÿæÿßÿ®ŸÜÿØ€å)


67. üëë Al-Mulk (The Sovereignty) - ÿßŸÑŸÖŸèŸÑŸÉ (ÿ≠⁄©ŸàŸÖÿ™)


68. üñãÔ∏è Al-Qalam (The Pen) - ÿßŸÑŸÇŸÑŸÖ (ŸÇŸÑŸÖ)


69. üîç Al-Haqqah (The Reality) - ÿßŸÑÿ≠ŸÇ€Å (ÿ≠ŸÇ€åŸÇÿ™)


70. ‚¨ÜÔ∏è Al-Ma'arij (The Ascending Stairways) - ÿßŸÑŸÖÿπÿßÿ±ÿ¨ (⁄Ü⁄ë⁄æŸÜ€í ⁄©€å ÿ≥€å⁄ë⁄æ€åÿß⁄∫)


71. üåä Nuh (Noah) - ŸÜŸàÿ≠ (ŸÜŸàÿ≠)


72. üëª Al-Jinn (The Jinn) - ÿßŸÑÿ¨ŸÜ (ÿ¨ŸÜÿßÿ™)


73. üïµÔ∏è‚Äç‚ôÇÔ∏è Al-Muzzammil (The Enshrouded One) - ÿßŸÑŸÖÿ≤ŸÖŸÑ (⁄ÜÿßÿØÿ± ÿßŸà⁄ë⁄æ€í €ÅŸàÿ¶€í)


74. üßï Al-Muddathir (The Cloaked One) - ÿßŸÑŸÖŸèÿØÿ´ÿ± (ŸæŸàÿ¥€åÿØ€Å)


75. üåÖ Al-Qari'ah (The Calamity) - ÿßŸÑŸÇÿßÿ±ÿπÿ© (ÿ¢ŸÅÿ™)


76. üßë‚Äçü§ù‚Äçüßë Al-Insan (Man) - ÿßŸÑÿßŸÜÿ≥ÿßŸÜ (ÿßŸÜÿ≥ÿßŸÜ)


77. ‚úâÔ∏è Al-Mursalat (The Emissaries) - ÿßŸÑŸÖŸèÿ±ÿ≥ŸÑÿßÿ™ (Ÿæ€ÅŸÜ⁄ÜÿßŸÜ€í ŸàÿßŸÑ€í)


78. üì£ An-Naba' (The Tidings) - ÿßŸÑŸÜÿ®ÿ£ (ÿÆÿ®ÿ±€å⁄∫)


79. ü™§ An-Nazi'at (Those who drag forth) - ÿßŸÑŸÜÿßÿ≤ÿπÿßÿ™ (⁄©⁄æ€åŸÜ⁄ÜŸÜ€í ŸàÿßŸÑ€í)


80. üò† Abasa (He frowned) - ÿπÿ®ÿ≥ (ÿßÿ≥ ŸÜ€í ⁄Ü€Åÿ±€Å ÿ®ÿØŸÑÿß)


81. üí• At-Takwir (The Overthrowing) - ÿßŸÑÿ™⁄©ŸàŸäÿ± (Ÿæ⁄æŸπŸÜÿß)


82. üíî Al-Infitar (The Cleaving) - ÿßŸÑÿßŸÜŸÅÿ∑ÿßÿ± (Ÿæ⁄æŸπŸÜÿß)


83. ‚öñÔ∏è Al-Mutaffifin (Defrauding) - ÿßŸÑŸÖÿ∑ŸÅŸÅŸäŸÜ (⁄©ŸÖ ÿ™ŸàŸÑŸÜ€í ŸàÿßŸÑ€í)


84. üåÄ Al-Inshiqaq (The Splitting Open) - ÿßŸÑÿßŸÜÿ¥ŸÇÿßŸÇ (Ÿæ⁄æŸπŸÜÿß)


85. üåå Al-Buruj (The Mansions of the Stars) - ÿßŸÑÿ®ÿ±Ÿàÿ¨ (ÿ≥ÿ™ÿßÿ±Ÿà⁄∫ ⁄©€í ⁄Ø⁄æÿ±)


86. üå† At-Tariq (The Morning Star) - ÿßŸÑÿ∑ÿßÿ±ŸÇ (ÿµÿ®ÿ≠ ⁄©ÿß ÿ≥ÿ™ÿßÿ±€Å)


87. üåç Al-Ala (The Most High) - ÿßŸÑÿ£ÿπŸÑŸâ (ÿ≥ÿ® ÿ≥€í ÿ®ŸÑŸÜÿØ)


88. üåä Al-Ghashiyah (The Overwhelming) - ÿßŸÑÿ∫ÿßÿ¥€å€Å (Ÿæÿ±ÿßŸÖŸÜ)


89. üåÖ Al-Fajr (The Dawn) - ÿßŸÑŸÅÿ¨ÿ± (ÿµÿ®ÿ≠)


90. üèôÔ∏è Al-Balad (The City) - ÿßŸÑÿ®ŸÑÿØ (ÿ¥€Åÿ±)


91. ‚òÄÔ∏è Ash-Shams (The Sun) - ÿßŸÑÿ¥ŸÖÿ≥ (ÿ≥Ÿàÿ±ÿ¨)


92. üåú Al-Lail (The Night) - ÿßŸÑŸÑ€åŸÑ (ÿ±ÿßÿ™)


93. üåÖ Ad-Duha (The Morning Hours) - ÿßŸÑÿ∂ÿ≠€å (ÿµÿ®ÿ≠ ⁄©€í ⁄Ø⁄æŸÜŸπ€í)


94. üìñ As-Sharh (The Relief) - ÿßŸÑÿ¥ÿ±ÿ≠ (ÿ¢ÿ±ÿßŸÖ)


95. üçà At-Tin (The Fig) - ÿßŸÑÿ™€åŸÜ (ÿßŸÜÿ¨€åÿ±)


96. üíß Al-Alaq (The Clot) - ÿßŸÑÿπŸÑŸÇ (ÿÆŸàŸÜ ⁄©ÿß ŸÑŸàÿ™⁄æ⁄ëÿß)


97. ‚ö° Al-Qadr (The Power) - ÿßŸÑŸÇÿØÿ± (ŸÇÿØÿ±ÿ™)


98. üìú Al-Bayyinah (The Clear Proof) - ÿßŸÑÿ®€åŸÜÿ© (Ÿàÿßÿ∂ÿ≠ ÿØŸÑ€åŸÑ)


99. üåç Az-Zalzalah (The Earthquake) - ÿßŸÑÿ≤ŸÑÿ≤ŸÑÿ© (ÿ≤ŸÑÿ≤ŸÑ€Å)


100. üêé Al-Adiyat (The Chargers) - ÿßŸÑÿπÿßÿØ€åÿßÿ™ (⁄Üÿßÿ±ÿ¨ ⁄©ÿ±ŸÜ€í ŸàÿßŸÑ€í)


101. ‚ö° Al-Qari'ah (The Calamity) - ÿßŸÑŸÇÿßÿ±ÿπÿ© (ÿ¢ŸÅÿ™)


102. üí∞ At-Takathur (The Abundance of Wealth) - ÿßŸÑÿ™⁄©ÿßÿ´ÿ± (ŸÖÿßŸÑ ⁄©€å ⁄©ÿ´ÿ±ÿ™)


103. ‚è≥ Al-Asr (The Time) - ÿßŸÑÿπÿµÿ± (ŸàŸÇÿ™)


104. üò† Al-Humazah (The Scandal-Monger) - ÿßŸÑ€ÅŸÖÿ≤€Å (⁄Üÿ∫ŸÑ€å ⁄©ÿ±ŸÜ€í ŸàÿßŸÑÿß)


105. üêò Al-Fil (The Elephant) - ÿßŸÑŸÅ€åŸÑ (€Åÿßÿ™⁄æ€å)


106. üïå Quraysh (Quraysh) - ŸÇÿ±€åÿ¥ (ŸÇÿ±€åÿ¥)


107. ü§≤ Al-Ma'un (Acts of Kindness) - ÿßŸÑŸÖÿßÿπŸàŸÜ (ŸÜ€å⁄©€å ⁄©€í ⁄©ÿßŸÖ)


108. üçá Al-Kawthar (The Abundance) - ÿßŸÑ⁄©Ÿàÿ´ÿ± (⁄©ÿ´ÿ±ÿ™)


109. ‚ùå Al-Kafirun (The Disbelievers) - ÿßŸÑ⁄©ÿßŸÅÿ±ŸàŸÜ (⁄©ÿßŸÅÿ±)


110. üõ°Ô∏è An-Nasr (The Help) - ÿßŸÑŸÜÿµÿ± (ŸÖÿØÿØ)


111. üî• Al-Lahab (The Flame) - ÿßŸÑŸÑ€Åÿ® (ÿ¥ÿπŸÑ€Å)


112. ‚ù§Ô∏è Al-Ikhlas (The Sincerity) - ÿßŸÑÿ•ÿÆŸÑÿßÿµ (ÿßÿÆŸÑÿßÿµ)


113. üåÖ Al-Falaq (The Daybreak) - ÿßŸÑŸÅŸÑŸÇ (ÿ∑ŸÑŸàÿπ ÿµÿ®ÿ≠)


114. üåê An-Nas (Mankind) - ÿßŸÑŸÜÿßÿ≥ (ÿßŸÜÿ≥ÿßŸÜ€åÿ™)`;

        await conn.sendMessage(
            from,
            {
                image: { url: `https://files.catbox.moe/v6zfno.jpg` },
                caption: dec,
                contextInfo: {
                    mentionedJid: [m.sender],
                    forwardingScore: 999,
                    isForwarded: true,
                    forwardedNewsletterMessageInfo: {
                        newsletterJid: '120363402829832961@newsletter',
                        newsletterName: '·¥Ä è·¥Ä…¥ Íú±·¥á·¥†·¥á…¥ ·¥ç·¥è·¥Ö·¥¢',
                        serverMessageId: 143
                    }
                }
            },
            { quoted: mek }
        );

        await conn.sendMessage(from, {
            audio: { url: 'https://github.com/JawadYT36/KHAN-DATA/raw/refs/heads/main/autovoice/Quran.m4a' },
            mimetype: 'audio/mp4',
            ptt: false
        }, { quoted: mek });
        
    } catch (e) {
        console.log(e);
        reply(`${e}`);
    }
});

cmd({
  pattern: "quote",
  desc: "Get a random inspiring quote.",
  category: "group",
  react: "üí¨",
  filename: __filename
}, async (conn, m, store, { from, reply }) => {
  try {
    const response = await axios.get("https://api.quotable.io/random");
    const { content, author } = response.data;

    const message = `üí¨ *"${content}"*\n- ${author}\n\n> *QUOTES BY QUEEN ELISA*`;
    reply(message);
  } catch (error) {
    console.error("Error fetching quote:", error);
    reply("‚ö†Ô∏è API issue or coding error, please check the logs!");
  }
});             
        
          
